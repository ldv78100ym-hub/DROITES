<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cours Interactif : Droites & Fonctions</title>
    
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <style>
        :root {
            --primary: #2c3e50;
            --secondary: #34495e;
            --accent: #3498db;
            --accent-hover: #2980b9;
            --bg: #ecf0f1;
            --text: #333;
            --card-bg: #fff;
            --success: #27ae60;
            --danger: #c0392b;
            --warning: #f1c40f;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0; padding: 0;
            background-color: var(--bg); color: var(--text);
            display: flex; flex-direction: column; min-height: 100vh;
        }

        /* --- 1. √âCRAN D'ACCUEIL --- */
        #welcome-screen {
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            height: 100vh; text-align: center;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white; position: fixed; width: 100%; z-index: 100;
            transition: transform 0.6s cubic-bezier(0.68, -0.55, 0.27, 1.55);
        }
        #welcome-screen h1 { font-size: 3rem; margin-bottom: 1rem; text-shadow: 0 2px 4px rgba(0,0,0,0.3); }
        .big-btn {
            background-color: var(--accent); color: white; border: none;
            padding: 15px 40px; font-size: 1.5rem; border-radius: 50px;
            cursor: pointer; box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            transition: transform 0.2s, background 0.3s;
        }
        .big-btn:hover { transform: scale(1.05); background-color: var(--accent-hover); }

        /* --- 2. INTERFACE DU COURS --- */
        #course-interface {
            display: none; flex-grow: 1; padding: 20px;
            max-width: 1100px; margin: 0 auto; width: 100%; box-sizing: border-box;
        }
        
        /* Navigation */
        .nav-grid {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 10px; margin-bottom: 20px;
        }
        .nav-btn {
            background: white; border: 2px solid var(--primary); color: var(--primary);
            padding: 12px; border-radius: 8px; cursor: pointer; font-weight: bold;
            transition: all 0.3s; text-align: center;
	    
            margin-bottom: 30px;   
        }
        .nav-btn:hover { background: #f00000; transform: translateY(-2px); }
        .nav-btn.active { background: var(--primary); color: white; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        
        /* Sous-navigation pour l'outil */
        .sub-nav {
            display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; margin-bottom: 20px;
        }
        .sub-nav-btn {
            background: var(--bg); border: 1px solid var(--primary); color: var(--primary);
            padding: 8px 15px; border-radius: 20px; cursor: pointer; font-size: 0.9rem;
            transition: all 0.2s;
        }
        .sub-nav-btn:hover, .sub-nav-btn.active {
            background: var(--primary); color: white;
        }
        .method-container {
            display: none; animation: fadeIn 0.3s;
        }
        .method-container.active { display: block; } 
      
        /* Contenu */
        .content-display {
            background: var(--card-bg); padding: 2rem; border-radius: 12px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.05); min-height: 500px;
        }
        .chapter { display: none; animation: fadeIn 0.4s ease-in; }
        .chapter.visible { display: block; }

        /* Vignettes (Chapitre 1) */
        .vignette-grid {
            display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;
        }
        .vignette-btn {
            padding: 20px; border: 2px solid #ddd; border-radius: 12px;
            background: white; cursor: pointer; transition: all 0.3s ease;
            text-align: left; position: relative; overflow: hidden;
        }
        .vignette-btn:hover { transform: translateY(-3px); box-shadow: 0 5px 15px rgba(0,0,0,0.1); border-color: var(--accent); }
        .vignette-btn.active { background-color: #eaf6ff; border-color: var(--accent); box-shadow: 0 0 0 2px var(--accent); }
        .vignette-btn.active::after {
            content: 'üëÅÔ∏è Affich√©'; position: absolute; top: 10px; right: 10px;
            font-size: 0.8rem; color: var(--accent); font-weight: bold;
        }
        .vignette-btn h3 { margin: 0 0 5px 0; color: var(--primary); font-size: 1.2rem; }
        .vignette-btn p { margin: 0; color: #666; font-size: 0.95rem; }
        .def-content { display: none; animation: fadeIn 0.3s; }
        .def-content.active { display: block; }

        /* Typographie Math√©matique */
        h2 { color: var(--accent); border-bottom: 2px solid #eee; padding-bottom: 10px; margin-top: 0; }
        .definition { background: #fff8e1; border-left: 5px solid #ffc107; padding: 15px; margin: 15px 0; border-radius: 4px; }
        .property { background: #e3f2fd; border-left: 5px solid #2196f3; padding: 15px; margin: 15px 0; border-radius: 4px; }
        
        /* Containers Graphiques */
        .canvas-container {
            display: flex; flex-direction: column; align-items: center;
            margin: 20px 0; background: #fafafa; padding: 10px; border-radius: 8px; border: 1px solid #eee;
        }
        canvas {
            background: #fff; border: 1px solid #ccc; border-radius: 4px;
            cursor: grab; box-shadow: inset 0 0 20px rgba(0,0,0,0.02); touch-action: none;
        }
        canvas:active { cursor: grabbing; }
        
        /* Canvas sp√©cifique pour les tableaux */
        #canvas-variation, #canvas-sign-table {
            margin-top: 15px;
            border: 1px solid #333; background: #fff;
        }

        .info-box {
            margin-top: 15px; padding: 15px; background: var(--secondary);
            color: white; border-radius: 8px; width: 100%; max-width: 600px;
            text-align: center; font-family: 'Consolas', monospace; font-size: 1.1rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            /* Ajout pour √©viter que le texte bouge trop */
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        .highlight-val { color: var(--warning); font-weight: bold; }
        .instructions { font-style: italic; color: #666; font-size: 0.9rem; margin-top: 10px; text-align: center; }
        .info-math { margin: 5px 0; font-size: 1.2rem; }

        /* Outil Calculatrice */
        .tool-box { background: var(--primary); color: white; padding: 20px; border-radius: 8px; text-align: center; }
        .input-row { display: flex; justify-content: center; gap: 20px; margin: 20px 0; flex-wrap: wrap; }
        input { padding: 10px; border-radius: 4px; border: none; width: 100px; text-align: center; font-size: 1rem; }
        .calc-btn { background: var(--accent); color: white; border: none; padding: 10px 25px; border-radius: 4px; cursor: pointer; font-size: 1rem; }
        .calc-btn:hover { background: var(--accent-hover); }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .back-home { margin-top: 20px; text-align: center; cursor: pointer; text-decoration: underline; color: #777; }
	/* Styles pour la modale Droits d'auteur */
        .modal {
            display: none; /* Cach√© par d√©faut */
            position: fixed; 
            z-index: 1000; 
            left: 0;
            top: 0;
            width: 100%; 
            height: 100%; 
            overflow: auto; 
            background-color: rgba(0,0,0,0.6); /* Fond sombre transparent */
            backdrop-filter: blur(2px);
        }

        .modal-content {
            background-color: var(--card-bg);
            margin: 5% auto; 
            padding: 25px; 
            border: 1px solid #888;
            width: 90%; 
            max-width: 700px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            color: var(--text);
            line-height: 1.6;
        }

        .close-modal {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.3s;
        }

        .close-modal:hover,
        .close-modal:focus {
            color: var(--danger);
            text-decoration: none;
        }
        
        .copyright-btn-container {
            text-align: center;
            margin: 40px 0 20px 0;
            padding-bottom: 20px;
        }
	/* --- Styles pour le module Exercices --- */
	.exercise-box {
    	    border: 2px solid var(--primary); padding: 20px; border-radius: 8px; margin-bottom: 20px;
    	    background: #fff; font-size: 1.2rem;
	}
	.actions { display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; }
	/* Ce code remplace vos anciennes d√©finitions .btn */
	.nav-exos .btn {
	    flex: 1 1 150px;
	    padding: 12px 15px;
	    font-size: 1rem;
	    font-weight: 600;
	    cursor: pointer;
	    border: 2px solid #2c3e50; 
	    background-color: #fff;
	    color: #2c3e50;
	    border-radius: 6px;
	    transition: all 0.3s ease;
	    text-align: center;
	    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
	}

	.nav-exos .btn:hover {
	    background-color: #eaf2f8;
	    transform: translateY(-2px);
	}
	.nav-exos .btn.active {
    background-color: black !important; /* Fond noir */
    color: white !important;            /* Texte blanc */
    border-color: black !important;     /* Bordure noire */
}
	.btn-help { background-color: var(--accent); } /* Adapt√© √† la palette principale */
	.btn-sol { background-color: var(--success); }
	.hidden-section {
	    display: none; margin-top: 15px; padding: 15px; border-left: 5px solid #ccc; background: #f9f9f9;
	}
	.help-container { border-color: var(--accent); }
	.sol-container { border-color: var(--success); }
	.tag-helper {
	    display: inline-block; background: #e1f0fa; color: #2980b9;
	    padding: 5px 10px; margin: 5px; border-radius: 15px; cursor: pointer; border: 1px solid #aed6f1;
	}
	.tag-helper:hover { background: #d4e6f1; }
	.step-detail { margin-bottom: 10px; line-height: 1.6; }
	.highlight { color: #c0392b; font-weight: bold; }
    </style>
</head>
<body>
    <div style="padding: 15px 20px; background-color: transparent;">
        <a href="https://ldv78100ym-hub.github.io/HOME/" style="
            text-decoration: none;
            background-color: var(--secondary);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            font-weight: bold;
            font-size: 0.95rem;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: background-color 0.3s, transform 0.2s;
        " onmouseover="this.style.backgroundColor='var(--accent)'; this.style.transform='translateY(-2px)'" 
          onmouseout="this.style.backgroundColor='var(--secondary)'; this.style.transform='translateY(0)'">
            üìÇ Autres chapitres
        </a>
    </div>
    <div id="welcome-screen">
        <h1>G√©om√©trie & Fonctions Affines</h1>
        <p>Cours complet & Laboratoire Interactif</p>
        <button class="big-btn" onclick="enterCourse()">Entrer dans le laboratoire</button>
    </div>

    <div id="course-interface">
        
        <nav class="nav-grid">
            <button class="nav-btn" onclick="showTab('def', initDefGraph)">1. D√©finition</button>
            <button class="nav-btn" onclick="showTab('var', initVarGraph)">2. Variations</button>
            <button class="nav-btn" onclick="showTab('vert', initVertGraph)">3. Droite Verticale</button>
            <button class="nav-btn" onclick="showTab('point', initPointGraph)">4. Point & Droite</button>
            <button class="nav-btn" onclick="showTab('pos', initPosGraph)">5. Positions Relatives</button>
            <button class="nav-btn" onclick="showTab('sign', initSignGraph)">6. Tableau de Signe</button>
            <button class="nav-btn" onclick="showTab('tool')">‚ö° M√©thodes de calcul</button>
            <button class="nav-btn" onclick="showTab('exos', initExos)">7. Entra√Ænement</button>
        </nav>

        <div class="content-display">
            
            <div id="intro-msg" class="chapter visible">
                <h2>Mode d'emploi</h2>
                <p>Bienvenue dans le module interactif sur les droites.</p>
                <ul>
                    <li>Cliquez sur les boutons ci-dessus pour naviguer entre les chapitres.</li>
                    <li>Utilisez la souris pour <strong>glisser le fond</strong> du graphique (d√©placer le rep√®re).</li>
                    <li>Attrapez les points color√©s pour manipuler les objets math√©matiques.</li>
                </ul>
            </div>

            <div id="def" class="chapter">
                <h2>1. D√©finitions Fondamentales</h2>
                
                <div class="vignette-grid">
                    <div class="vignette-btn active" onclick="switchDefMode('geo', this)">
                        <h3>üìê La Droite</h3>
                        <p>Vision G√©om√©trique</p>
                    </div>
                    <div class="vignette-btn" onclick="switchDefMode('ana', this)">
                        <h3>üìà Fonction Affine</h3>
                        <p>Vision Analytique</p>
                    </div>
                </div>

                <div id="content-geo" class="def-content active">
                    <div class="definition">
                        En g√©om√©trie, une droite est un ensemble infini de points align√©s.<br>
                        √âquation r√©duite : \( y = mx + p \) (si non verticale).
                    </div>
                </div>

                <div id="content-ana" class="def-content">
                    <div class="property">
                        Une fonction affine \( f \) est d√©finie par \( f(x) = mx + p \).<br>
                        Le signe de \( m \) donne le sens de variation (voir Chapitre 2).
                    </div>
                </div>

                <div class="canvas-container">
                    <canvas id="canvas-def" width="600" height="300"></canvas>
                    <div id="info-def" class="info-box">Chargement...</div>
                    <p class="instructions">üîµ Modifiez \(p\). üü£ Modifiez \(m\). ‚úã Glissez le fond pour d√©placer le rep√®re.</p>
                </div>
            </div>

            <div id="var" class="chapter">
                <h2>2. Variations et Inclinaison</h2>
                <div class="property">
                    <p>Le sens de variation d√©pend du signe de \(m\).</p>
                    <ul>
                        <li>\( m > 0 \) : Fonction croissante.</li>
                        <li>\( m < 0 \) : Fonction d√©croissante.</li>
                        <li>\( m = 0 \) : Fonction constante.</li>
                    </ul>
                </div>
                <div class="canvas-container">
                    <canvas id="canvas-var" width="600" height="300"></canvas>
                    
                    <canvas id="canvas-variation" width="500" height="150"></canvas>
                    
                    <div id="info-var" class="info-box">...</div>
                    <p class="instructions">Translation (Bleu) / Rotation (Violet)</p>
                </div>
            </div>

            <div id="vert" class="chapter">
                <h2>3. Cas particulier : La Droite Verticale</h2>
                <div class="definition">
                    Son √©quation est de la forme \( x = c \).
                    Tous les points de la droite ont la m√™me abscisse \(c\), mais leur ordonn√©e \(y\) est libre.
                </div>
                <div class="canvas-container">
                    <canvas id="canvas-vert" width="600" height="350"></canvas>
                    <div id="info-vert" class="info-box">...</div>
                    <p class="instructions">üüß D√©placez la droite ou üü† faites glisser le point A le long de la droite.</p>
                </div>
            </div>

            <div id="point" class="chapter">
                <h2>4. Appartenance d'un point</h2>
                <div class="property">
                    Le point \( A(x_A; y_A) \) appartient √† la droite si :
                    $$ y_A = m \times x_A + p $$
                </div>
                <div class="canvas-container">
                    <canvas id="canvas-point" width="600" height="350"></canvas>
                    <div id="info-point" class="info-box">...</div>
                    <p class="instructions">üî¥ D√©placez le point A. üîµ Modifiez \(p\). üü£ Modifiez \(m\).</p>
                </div>
            </div>

            <div id="pos" class="chapter">
                <h2>5. Positions Relatives</h2>
                <div class="property">
                    <ul>
                        <li><strong>Confondue :</strong> Si \( m_1 = m_2 \) et \( p_1 = p_2 \).</li>
                        <li><strong>Parall√®les :</strong> Si \( m_1 = m_2 \) et \( p_1 \neq p_2 \).</li>
                        <li><strong>Perpendiculaires :</strong> Si \( m_1 \times m_2 = -1 \).</li>
                        <li><strong>S√©cantes :</strong> Dans tous les autres cas.</li>
                    </ul>
                </div>
                <div class="canvas-container">
                    <canvas id="canvas-pos" width="600" height="350"></canvas>
                    <div id="info-pos" class="info-box">...</div>
                    <p class="instructions">‚ö´ D√©placez la droite grise (m1, p1). üîµ/üü£ D√©placez la droite bleue (m2, p2).</p>
                </div>
            </div>

            <div id="sign" class="chapter">
                <h2>6. Tableau de Signe de $mx+p$</h2>
                <div class="property">
                    La fonction \(f(x) = mx+p\) est nulle en sa racine \(x_0 = -\dfrac{p}{m}\).
		    <br>
                    Le signe de \(f(x)\) est :
                    <ul>
                        <li>Du signe oppos√© √† \(m\) avant \(x_0\).</li>
                        <li>Du signe de \(m\) apr√®s \(x_0\).</li>
                    </ul>
                    Si \(m=0\), le signe est constant (signe de \(p\)).
                </div>
                <div class="canvas-container">
                    <canvas id="canvas-sign" width="600" height="300"></canvas>
                    
                    <canvas id="canvas-sign-table" width="500" height="150"></canvas>
                    
                    <div id="info-sign" class="info-box">...</div>
                    <p class="instructions">Translation (Bleu) / Rotation (Violet). Observez la racine (point jaune) et l'axe X.</p>
                </div>
            </div>

            <div id="tool" class="chapter">
                <h2>D√©terminer l'√©quation \( y = mx + p \)</h2>
                
                <div class="sub-nav">
                    <button class="sub-nav-btn active" onclick="switchMethod('A')">A. Lecture Graphique (2 Points)</button>
                    <button class="sub-nav-btn" onclick="switchMethod('B')">B. Lecture Graphique (m et p)</button>
                    <button class="sub-nav-btn" onclick="switchMethod('C')">C. Calcul : 2 Points</button>
                    <button class="sub-nav-btn" onclick="switchMethod('D')">D. Calcul : Point & m</button>
                    <button class="sub-nav-btn" onclick="switchMethod('E')">E. Calcul : Point & p</button>
                </div>

                <div id="method-A" class="method-container active">
                    <div class="property">
                        <strong>Cas A :</strong> On rep√®re deux points \(A\) et \(B\) sur la droite dont les coordonn√©es sont enti√®res (lisibles).<br>
                        On calcule : $$ m = \dfrac{y_B - y_A}{x_B - x_A} $$
                        Puis on lit ou calcule \(p\).
                    </div>
                    <div class="canvas-container">
                        <canvas id="canvas-method-a" width="600" height="350"></canvas>
                        <button class="calc-btn" onclick="generateRandomGraphA()" style="margin-top:10px;">üîÑ Nouvel Exemple</button>
                        <div id="info-method-a" class="info-box">...</div>
                    </div>
                </div>

                <div id="method-B" class="method-container">
                    <div class="property">
                        <strong>Cas B :</strong> L'ordonn√©e √† l'origine \(p\) est lisible (intersection axe Y).<br>
                        Pour \(m\), on part de \(p\), on avance de 1 vers la droite, et on mesure la mont√©e/descente.
                    </div>
                    <div class="canvas-container">
                        <canvas id="canvas-method-b" width="600" height="350"></canvas>
                        <button class="calc-btn" onclick="generateRandomGraphB()" style="margin-top:10px;">üîÑ Nouvel Exemple</button>
                        <div id="info-method-b" class="info-box">...</div>
                    </div>
                </div>

                <div id="method-C" class="method-container">
                    <div class="tool-box">
                        <p><strong>√âtape 1 :</strong> Entrez les coordonn√©es de deux points \( A \) et \( B \).</p>
                        <div class="input-row">
                            \( A \) : x <input type="number" id="cxA" placeholder="xA"> y <input type="number" id="cyA" placeholder="yA">
                        </div>
                        <div class="input-row">
                            \( B \) : x <input type="number" id="cxB" placeholder="xB"> y <input type="number" id="cyB" placeholder="yB">
                        </div>

                        <hr style="border-color: rgba(255,255,255,0.3); margin: 20px 0;">

                        <p><strong>√âtape 2 :</strong> Remplacez les valeurs dans la formule de \( m \).</p>
                        <div style="display:flex; justify-content:center; align-items:center; font-size:1.2rem; margin-bottom:15px;">
                            <span style="margin-right:10px;">\( m = \dfrac{y_B - y_A}{x_B - x_A} = \)</span>
                            <div style="text-align:center; display:inline-block; vertical-align:middle;">
                                <div style="border-bottom:2px solid white; padding-bottom:5px; margin-bottom:5px;">
                                    <input type="number" id="in_yB" style="width:60px; text-align:center;" placeholder="yB"> - 
                                    <input type="number" id="in_yA" style="width:60px; text-align:center;" placeholder="yA">
                                </div>
                                <div>
                                    <input type="number" id="in_xB" style="width:60px; text-align:center;" placeholder="xB"> - 
                                    <input type="number" id="in_xA" style="width:60px; text-align:center;" placeholder="xA">
                                </div>
                            </div>
                        </div>

                        <p><strong>√âtape 3 :</strong> Remplacez les valeurs dans la formule de \( p \) (avec le point A).</p>
                        <div style="font-size:1.2rem; margin-bottom:20px;">
                            \( p = y_A - m \times x_A = \) 
                            <input type="number" id="in_p_yA" style="width:60px; text-align:center;" placeholder="yA"> - 
                            <input type="number" id="in_p_m" style="width:70px; text-align:center;" placeholder="m trouv√©"> \(\times\) 
                            <input type="number" id="in_p_xA" style="width:60px; text-align:center;" placeholder="xA">
                        </div>

                        <button class="calc-btn" onclick="calcModeC()">V√©rifier et Calculer</button>
                        <div id="res-method-c" style="margin-top:15px; text-align:left;"></div>
                    </div>
                </div>

                <div id="method-D" class="method-container">
                    <div class="tool-box">
                        <p><strong>√âtape 1 :</strong> Entrez les coordonn√©es du point \( A \) et le coefficient \( m \).</p>
                        <div class="input-row">
                            \( A \) : x <input type="number" id="dxA" placeholder="xA"> y <input type="number" id="dyA" placeholder="yA">
                        </div>
                        <div class="input-row">
                            Coefficient \( m \) : <input type="number" id="dm" placeholder="m">
                        </div>

                        <hr style="border-color: rgba(255,255,255,0.3); margin: 20px 0;">

                        <p><strong>√âtape 2 :</strong> Remplacez les valeurs dans la formule de \( p \).</p>
                        <div style="font-size:1.2rem; margin-bottom:20px;">
                            \( p = y_A - m \times x_A = \) 
                            <input type="number" id="in_d_yA" style="width:60px; text-align:center;" placeholder="yA"> - 
                            <input type="number" id="in_d_m" style="width:60px; text-align:center;" placeholder="m"> \(\times\) 
                            <input type="number" id="in_d_xA" style="width:60px; text-align:center;" placeholder="xA">
                        </div>

                        <button class="calc-btn" onclick="calcModeD()">V√©rifier et Calculer</button>
                        <div id="res-method-d" style="margin-top:15px; text-align:left;"></div>
                    </div>
                </div>

                <div id="method-E" class="method-container">
                    <div class="tool-box">
                        <p><strong>√âtape 1 :</strong> Entrez les coordonn√©es du point \( A \) et l'ordonn√©e √† l'origine \( p \).</p>
                        <div class="input-row">
                            \( A \) : x <input type="number" id="exA" placeholder="xA"> y <input type="number" id="eyA" placeholder="yA">
                        </div>
                        <div class="input-row">
                            Ordonn√©e √† l'origine \( p \) : <input type="number" id="ep" placeholder="p">
                        </div>

                        <hr style="border-color: rgba(255,255,255,0.3); margin: 20px 0;">

                        <p><strong>√âtape 2 :</strong> Remplacez les valeurs dans la formule de \( m \).</p>
                        <div style="display:flex; justify-content:center; align-items:center; font-size:1.2rem; margin-bottom:15px;">
                            <span style="margin-right:10px;">\( m = \dfrac{y_A - p}{x_A} = \)</span>
                            <div style="text-align:center; display:inline-block; vertical-align:middle;">
                                <div style="border-bottom:2px solid white; padding-bottom:5px; margin-bottom:5px;">
                                    <input type="number" id="in_e_yA" style="width:60px; text-align:center;" placeholder="yA"> - 
                                    <input type="number" id="in_e_p" style="width:60px; text-align:center;" placeholder="p">
                                </div>
                                <div>
                                    <input type="number" id="in_e_xA" style="width:60px; text-align:center;" placeholder="xA">
                                </div>
                            </div>
                        </div>

                        <button class="calc-btn" onclick="calcModeE()">V√©rifier et Calculer</button>
                        <div id="res-method-e" style="margin-top:15px; text-align:left;"></div>
                    </div>
                </div>
            </div>
		
	    <div id="exos" class="chapter">
    <h2>Banque d'Exercices Dynamiques</h2>
    
    <div class="nav-exos">
        <button class="nav-btn" onclick="loadExercise('belong')">1. Point sur Droite ?</button>
        <button class="nav-btn" onclick="loadExercise('calc_m')">2. Calculer m</button>
        <button class="nav-btn" onclick="loadExercise('eq_2pts')">3. √âq. (2 Points)</button>
	<button class="nav-btn" onclick="loadExercise('point_et_m')">4. √âq. (1 Point & m)</button>
	<button class="nav-btn" onclick="loadExercise('point_et_p')">5. √âq. (1 Point & p)</button>
        <button class="nav-btn" onclick="loadExercise('lecture_graphique')">6. Lecture Graphique</button>
	<button class="nav-btn" onclick="loadExercise('solver_simple')">7. Probl√®me Lin√©aire</button>
	<button class="nav-btn" onclick="loadExercise('solver_percent')">8. Pourcentages</button>
    </div>

    <div class="exercise-box">
        <div id="exercise-area">S√©lectionnez un exercice ci-dessus.</div>
    </div>

    <div class="actions">
        <button class="btn btn" onclick="loadExercise(currentType)">üîÑ Nouvel √ânonc√©</button>
        <button class="btn btn-help" onclick="toggleDisplay('help-area')">üí° Aide</button>
        <button class="btn btn-sol" onclick="toggleDisplay('sol-area')">üìù Solution</button>
    </div>

    <div id="help-area" class="hidden-section help-container">
        <strong>Aides disponibles :</strong>
        <div id="help-tags"></div>
        <div id="help-content" style="margin-top:15px; font-style:italic;">Cliquez sur un tag pour voir l'aide.</div>
    </div>

    <div id="sol-area" class="hidden-section sol-container">
        <h3>Correction D√©taill√©e</h3>
        <div id="solution-content"></div>
    </div>
</div>
        </div>
        
        <div class="back-home" onclick="exitCourse()">‚Üê Revenir √† l'√©cran d'accueil</div>
    </div>
    
    <div class="copyright-btn-container">
        <button id="copyright-btn" class="calc-btn" style="background-color: var(--secondary); font-size: 0.9rem; width: auto; padding: 10px 20px;">
            ‚öñÔ∏è Droits d'Auteur
        </button>
    </div>

    <div id="copyright-modal" class="modal">
        <div class="modal-content">
            <span class="close-modal">&times;</span>
            <h2 style="color: var(--primary); border-bottom: 2px solid var(--accent); padding-bottom: 10px;">
                ‚öñÔ∏è Droits d'Auteur et Licence d'Utilisation
            </h2>
            <p><strong>Auteur :</strong> Yann Merdy (<a href="mailto:yann.merdy@gmail.com" style="color: var(--accent);">yann.merdy@gmail.com</a>) - D√©cembre 2025</p>
            
            <h3 style="color: var(--secondary);">Licence d'Utilisation Non Commerciale</h3>
            <p>Ce code HTML/CSS/JavaScript ainsi que le contenu g√©n√©r√© par l'application sont la propri√©t√© intellectuelle exclusive de l'auteur, Yann Merdy.</p>
            
            <h3 style="color: var(--secondary);">Conditions :</h3>
            <ul style="text-align: left;">
                <li><strong>Utilisation Priv√©e et √âducative (Autoris√©e) :</strong> Vous √™tes autoris√©.e √† utiliser, copier, modifier et distribuer ce code et son contenu <em>uniquement</em> √† des fins personnelles, √©ducatives et non lucratives.</li>
                <li><strong>Utilisation Commerciale (Interdite) :</strong> Toute utilisation, distribution, int√©gration ou reproduction du code ou du contenu (total ou partiel) √† des fins <em>commerciales, lucratives ou professionnelles</em> est <strong>strictement interdite</strong> sans un accord √©crit pr√©alable et explicite de l'auteur.</li>
                <li><strong>Attribution :</strong> Toute reproduction ou modification doit conserver la mention de l'auteur originale (Yann Merdy) et la pr√©sente notice de droits d'auteur.</li>
            </ul>
            <p style="font-size: 0.9em; margin-top: 20px; border-top: 1px solid #eee; padding-top: 10px;">
                Pour toute demande d'utilisation commerciale ou de licence sp√©cifique, veuillez contacter l'auteur √† l'adresse indiqu√©e ci-dessus.
            </p>
        </div>
    </div>

    <script>
        // --- GESTION NAVIGATION ---
        function enterCourse() {
            document.getElementById('welcome-screen').style.transform = "translateY(-100%)";
            document.getElementById('course-interface').style.display = "block";
        }

        function exitCourse() {
            document.getElementById('welcome-screen').style.transform = "translateY(0)";
            setTimeout(() => {
                document.getElementById('course-interface').style.display = "none";
            }, 500);
        }

        const initializedGraphs = {};

        function showTab(id, initFunc) {
            // Emp√™cher l'√©v√©nement d'√™tre d√©clench√© par un √©l√©ment enfant du bouton si besoin
            let target = event.target.closest('.nav-btn');
            
            document.querySelectorAll('.chapter').forEach(ch => ch.classList.remove('visible'));
            document.querySelectorAll('.nav-btn').forEach(btn => btn.classList.remove('active'));
            
            document.getElementById(id).classList.add('visible');
            if (target) {
                target.classList.add('active');
            } else {
                // Fallback si l'√©v√©nement n'est pas clair (ex: appel direct)
                document.querySelector(`[onclick="showTab('${id}', ${initFunc ? initFunc.name : 'null'})"]`).classList.add('active');
            }


            if (initFunc && !initializedGraphs[id]) {
                // Utiliser setTimeout pour s'assurer que le canvas est visible et que MathJax est pr√™t
                setTimeout(() => initFunc(), 50);
                initializedGraphs[id] = true;
            }
        }

        // --- CLASSE DEDIEE AU TABLEAU DE VARIATION (CANVAS) ---
        class VariationTable {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.width = this.canvas.width;
                this.height = this.canvas.height;
                this.fontMath = 'italic 24px "Times New Roman", Times, serif';
                this.fontInf = 'italic 20px "Times New Roman", Times, serif';
            }

            drawTikZArrow(ctx, fromX, fromY, toX, toY) {
                const headLength = 15;
                const angle = Math.atan2(toY - fromY, toX - fromX);
                
                ctx.beginPath();
                ctx.moveTo(fromX, fromY);
                ctx.lineTo(toX, toY);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(toX, toY);
                ctx.lineTo(toX - headLength * Math.cos(angle - Math.PI / 8), toY - headLength * Math.sin(angle - Math.PI / 8));
                ctx.lineTo(toX - headLength * Math.cos(angle + Math.PI / 8), toY - headLength * Math.sin(angle + Math.PI / 8));
                ctx.closePath();
                ctx.fillStyle = "black";
                ctx.fill();
            }

            draw(m, p) {
                const ctx = this.ctx;
                ctx.clearRect(0, 0, this.width, this.height);
                ctx.fillStyle = "black";
                ctx.strokeStyle = "black";
                ctx.lineWidth = 1.5;

                // Structure du tableau
                ctx.beginPath();
                ctx.moveTo(0, 50); ctx.lineTo(this.width, 50);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(80, 0); ctx.lineTo(80, this.height);
                ctx.stroke();

                // Texte En-t√™te
                ctx.font = this.fontMath;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText("x", 40, 25);
                ctx.fillText("f(x)", 40, 100);

                // Bornes Infinies
                ctx.font = this.fontInf;
                ctx.fillText("‚àí‚àû", 130, 25);
                ctx.fillText("+‚àû", this.width - 50, 25);

                // Logique Fl√®ches et Limites
                const yTop = 75; const yBot = 125; const yMid = 100;
                ctx.font = this.fontInf;

                if (m > 0.05) {
                    // CROISSANTE
                    ctx.textAlign = "left"; ctx.fillText("‚àí‚àû", 130, yBot);
                    ctx.textAlign = "right"; ctx.fillText("+‚àû", this.width - 50, yTop);
                    this.drawTikZArrow(ctx, 160, yBot - 5, this.width - 80, yTop + 5);
                } else if (m < -0.05) {
                    // D√âCROISSANTE
                    ctx.textAlign = "left"; ctx.fillText("+‚àû", 130, yTop);
                    ctx.textAlign = "right"; ctx.fillText("‚àí‚àû", this.width - 50, yBot);
                    this.drawTikZArrow(ctx, 160, yTop + 5, this.width - 80, yBot - 5);
                } else {
                    // CONSTANTE
                    const valP = p.toFixed(1);
                    ctx.textAlign = "left"; ctx.fillText(valP, 130, yMid);
                    ctx.textAlign = "right"; ctx.fillText(valP, this.width - 50, yMid);
                    this.drawTikZArrow(ctx, 160, yMid, this.width - 80, yMid);
                }
            }
        }

        // --- CLASSE DEDIEE AU TABLEAU DE SIGNE (CANVAS) ---
        class SignTable {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.width = this.canvas.width;
                this.height = this.canvas.height;
                this.fontMath = 'italic 24px "Times New Roman", Times, serif';
                this.fontInf = 'italic 20px "Times New Roman", Times, serif';
                this.fontSign = 'bold 36px Arial';
            }

            draw(m, p) {
                const ctx = this.ctx;
                ctx.clearRect(0, 0, this.width, this.height);
                ctx.fillStyle = "black";
                ctx.strokeStyle = "black";
                ctx.lineWidth = 1.5;
                const root = (Math.abs(m) < 0.01) ? NaN : -p / m; // x0 = -p/m
                const isConstant = Math.abs(m) < 0.01;
                
                // Structure du tableau
                ctx.beginPath();
                ctx.moveTo(0, 50); ctx.lineTo(this.width, 50);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(80, 0); ctx.lineTo(80, this.height);
                ctx.stroke();

                // Texte En-t√™te
                ctx.font = this.fontMath;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText("x", 40, 25);
		ctx.fillText("f(x)", 40, 100);
                // MODIFICATION : On retire l'affichage statique "mx+p"
                // L'expression compl√®te est maintenant rendue en LaTeX dans l'info-box (divVals)
                // ctx.fillText("mx+p", 40, 100); 

                // Bornes Infinies
                ctx.font = this.fontInf;
                ctx.fillText("‚àí‚àû", 130, 25);
                ctx.fillText("+‚àû", this.width - 50, 25);

                ctx.font = this.fontSign;
                const signX = (130 + this.width - 50) / 2;
                
                if (isConstant) {
                    // CAS M=0 (Fonction Constante)
                    ctx.fillStyle = (p > 0.01) ? 'green' : (p < -0.01) ? 'red' : 'gray';
                    ctx.fillText((p > 0.01) ? '+' : (p < -0.01) ? '-' : '0', signX, 100);
                } else {
                    // CAS M!=0 (Une seule racine)
                    const rootX = this.width / 2;
                    
                    // Ligne verticale pour la racine (commence √† y=50 pour ne pas couper la ligne des x)
                    ctx.beginPath();
                    ctx.moveTo(rootX, 50); 
                    ctx.lineTo(rootX, this.height);
                    ctx.stroke();

                    // Affichage de la racine
                    ctx.font = this.fontInf;
                    ctx.fillStyle = 'black';
                    ctx.fillText(root.toFixed(1), rootX, 25);

                    // Z√©ro
                    ctx.font = '24px Arial';
                    ctx.fillText('0', rootX, 100);

                    // Signes
                    const leftX = (130 + rootX) / 2;
                    const rightX = (rootX + this.width - 50) / 2;

                    if (m > 0) {
                        // M > 0 : - puis +
                        ctx.fillStyle = 'red';
                        ctx.fillText('-', leftX, 100);
                        ctx.fillStyle = 'green';
                        ctx.fillText('+', rightX, 100);
                    } else {
                        // M < 0 : + puis -
                        ctx.fillStyle = 'green';
                        ctx.fillText('+', leftX, 100);
                        ctx.fillStyle = 'red';
                        ctx.fillText('-', rightX, 100);
                    }
                }
            }
        }


        // --- LOGIQUE VIGNETTES CHAPITRE 1 ---
        let currentDefMode = 'geo';
        let defGraphInstance = null;
        let variationTableInstance = null; 

        function switchDefMode(mode, btnElement) {
            currentDefMode = mode;
            
            document.querySelectorAll('.vignette-btn').forEach(b => b.classList.remove('active'));
            btnElement.classList.add('active');
            document.querySelectorAll('.def-content').forEach(c => c.classList.remove('active'));
            document.getElementById('content-' + mode).classList.add('active');
            
            if(defGraphInstance) defGraphInstance.draw();
        }

        // --- MOTEUR GRAPHIQUE ---
        class GraphEngine {
            constructor(canvasId, updateCallback) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.width = this.canvas.width;
                this.height = this.canvas.height;
                this.updateCallback = updateCallback;

                this.scale = 30;
                this.originX = this.width / 2;
                this.originY = this.height / 2;

                this.isDragging = false;
                this.dragTarget = null;
                this.mousePos = { x: 0, y: 0 };
                this.lastPixPos = { x: 0, y: 0 };

                this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
                this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
                this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
                this.canvas.addEventListener('mouseleave', this.handleMouseUp.bind(this));
                this.canvas.addEventListener('touchstart', (e) => {
                    const touch = e.touches[0];
                    const mouseEvent = new MouseEvent("mousedown", {clientX: touch.clientX, clientY: touch.clientY});
                    this.canvas.dispatchEvent(mouseEvent);
                }, false);
                this.canvas.addEventListener('touchmove', (e) => {
                   const touch = e.touches[0];
                   const mouseEvent = new MouseEvent("mousemove", {clientX: touch.clientX, clientY: touch.clientY});
                   this.canvas.dispatchEvent(mouseEvent);
                   if(this.isDragging) e.preventDefault(); 
                }, {passive: false});
                this.canvas.addEventListener('touchend', (e) => {
                   const mouseEvent = new MouseEvent("mouseup", {});
                   this.canvas.dispatchEvent(mouseEvent);
                }, false);

                this.draw();
            }

            toPixelX(x) { return this.originX + x * this.scale; }
            toPixelY(y) { return this.originY - y * this.scale; }
            toMathX(pixX) { return (pixX - this.originX) / this.scale; }
            toMathY(pixY) { return (this.originY - pixY) / this.scale; }

            drawAxes() {
                const ctx = this.ctx;
                ctx.clearRect(0, 0, this.width, this.height);
                
                const minX = Math.floor(this.toMathX(0));
                const maxX = Math.ceil(this.toMathX(this.width));
                const minY = Math.floor(this.toMathY(this.height));
                const maxY = Math.ceil(this.toMathY(0));

                ctx.beginPath(); ctx.strokeStyle = '#eee'; ctx.lineWidth = 1;
                for(let i = minX; i <= maxX; i++) {
                    let px = this.toPixelX(i); ctx.moveTo(px, 0); ctx.lineTo(px, this.height);
                }
                for(let i = minY; i <= maxY; i++) {
                    let py = this.toPixelY(i); ctx.moveTo(0, py); ctx.lineTo(this.width, py);
                }
                ctx.stroke();

                ctx.beginPath(); ctx.strokeStyle = '#333'; ctx.lineWidth = 2; ctx.fillStyle = '#333';
                if (this.originY >= 0 && this.originY <= this.height) {
                    ctx.moveTo(0, this.originY); ctx.lineTo(this.width, this.originY);
                    ctx.moveTo(this.width, this.originY); ctx.lineTo(this.width - 10, this.originY - 5); ctx.lineTo(this.width - 10, this.originY + 5); ctx.fill();
                    ctx.font = 'italic 20px "Times New Roman", Times, serif'; ctx.textAlign = 'right'; ctx.textBaseline = 'top';
                    ctx.fillText("x", this.width - 5, this.originY + 8);
                }
                if (this.originX >= 0 && this.originX <= this.width) {
                    ctx.moveTo(this.originX, 0); ctx.lineTo(this.originX, this.height);
                    ctx.moveTo(this.originX, 0); ctx.lineTo(this.originX - 5, 10); ctx.lineTo(this.originX + 5, 10); ctx.fill();
                    ctx.textAlign = 'left'; ctx.textBaseline = 'bottom';
                    ctx.fillText("y", this.originX + 10, 15);
                }
                ctx.stroke();
                ctx.fillStyle = '#777'; ctx.font = '12px Arial'; ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic';
                ctx.fillText('0', this.originX - 12, this.originY + 15);
                ctx.fillText('1', this.toPixelX(1)-3, this.originY + 15);
                ctx.fillText('1', this.originX - 15, this.toPixelY(1)+3);
            }

            drawLine(m, p, color = '#3498db', thickness = 2) {
                const minX = this.toMathX(0); const maxX = this.toMathX(this.width);
                const x1 = minX - 10; const y1 = m * x1 + p;
                const x2 = maxX + 10; const y2 = m * x2 + p;
                this.ctx.beginPath(); this.ctx.strokeStyle = color; this.ctx.lineWidth = thickness;
                this.ctx.moveTo(this.toPixelX(x1), this.toPixelY(y1));
                this.ctx.lineTo(this.toPixelX(x2), this.toPixelY(y2));
                this.ctx.stroke();
            }

            drawVerticalLine(c, color = '#e67e22') {
                this.ctx.beginPath(); this.ctx.strokeStyle = color; this.ctx.lineWidth = 2;
                this.ctx.moveTo(this.toPixelX(c), 0); this.ctx.lineTo(this.toPixelX(c), this.height);
                this.ctx.stroke();
            }

            drawPoint(x, y, color = '#3498db', radius = 6) {
                this.ctx.beginPath(); this.ctx.fillStyle = color;
                this.ctx.arc(this.toPixelX(x), this.toPixelY(y), radius, 0, Math.PI * 2);
                this.ctx.fill(); this.ctx.strokeStyle = 'white'; this.ctx.lineWidth = 2; this.ctx.stroke();
            }

            handleMouseDown(e) {
                this.isDragging = true; this.dragTarget = null;
                const rect = this.canvas.getBoundingClientRect();
                this.lastPixPos = { x: e.clientX, y: e.clientY };
                this.mousePos = { x: this.toMathX(e.clientX - rect.left), y: this.toMathY(e.clientY - rect.top) };
                this.draw();
                if (!this.dragTarget) { this.dragTarget = 'pan'; this.canvas.style.cursor = 'grabbing'; }
            }

            handleMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                this.mousePos = { x: this.toMathX(e.clientX - rect.left), y: this.toMathY(e.clientY - rect.top) };
                if (this.isDragging) {
                    if (this.dragTarget === 'pan') {
                        const dx = e.clientX - this.lastPixPos.x; const dy = e.clientY - this.lastPixPos.y;
                        this.originX += dx; this.originY += dy;
                        this.lastPixPos = { x: e.clientX, y: e.clientY };
                    }
                    this.draw();
                }
            }

            handleMouseUp() { 
                this.isDragging = false; this.dragTarget = null; this.canvas.style.cursor = 'grab'; this.draw(); 
            }
            
            isMouseNear(x, y) {
                const dx = this.mousePos.x - x; const dy = this.mousePos.y - y;
                // Check if distance is less than 0.5 units (about 15 pixels)
                return Math.sqrt(dx*dx + dy*dy) < 0.5;
            }

            draw() { this.drawAxes(); if (this.updateCallback) this.updateCallback(this, this.mousePos); }
        }

        // --- FONCTIONS SP√âCIFIQUES ---

        // 1. Definition
        function initDefGraph() {
            let m = 0.5, p = 1;
            const infoBox = document.getElementById('info-def');
            
            defGraphInstance = new GraphEngine('canvas-def', (g, mouse) => {
                const h1X = 0, h1Y = p; 
                const h2X = 5, h2Y = m * h2X + p; 

                if (g.isDragging) {
                    if (g.dragTarget === 'p') {
                        p = Math.round(mouse.y * 10) / 10;
                    } else if (g.dragTarget === 'm') {
                        if (Math.abs(mouse.x) > 0.1) m = (mouse.y - p) / mouse.x;
                    } else if (!g.dragTarget) { 
                        if (g.isMouseNear(h1X, h1Y)) g.dragTarget = 'p';
                        else if (g.isMouseNear(h2X, h2Y)) g.dragTarget = 'm';
                    }
                }

                g.drawLine(m, p);
                g.drawPoint(0, p, '#2980b9');
                g.drawPoint(h2X, m * h2X + p, '#8e44ad');

                let sign = p >= 0 ? '+' : '';
                
                if (currentDefMode === 'geo') {
                    infoBox.innerHTML = `<strong>√âquation de droite :</strong><br><span class="highlight-val">y = ${m.toFixed(2)}x ${sign}${p.toFixed(1)}</span>`;
                } else {
                    infoBox.innerHTML = `<strong>Fonction Affine :</strong><br><span class="highlight-val">f(x) = ${m.toFixed(2)}x${sign}${p.toFixed(1)}</span>`;
                }
            });
        }

        // 2. Variations (Modifi√© pour affichage Latex complet)
        function initVarGraph() {
            let m = 1, p = 0; 
            const infoBox = document.getElementById('info-var');
            
            infoBox.innerHTML = ''; 
            const divVals = document.createElement('div');
            const divText = document.createElement('div');
            divText.style.marginTop = "10px";
            divText.style.minHeight = "40px"; 
            infoBox.appendChild(divVals);
            infoBox.appendChild(divText);

            let lastState = null; 

            variationTableInstance = new VariationTable('canvas-variation');

            new GraphEngine('canvas-var', (g, mouse) => {
                const PRECISION_DRAG = 10;
                const TOL_M_ZERO = 0.1;

                const minY = g.toMathY(g.height - 10);
                const maxY = g.toMathY(10);
                let clampedMouseY = Math.min(Math.max(mouse.y, minY), maxY);

                const transX = 0; const rotX = 6; 
                
                if (g.isDragging) {
                    if (g.dragTarget === 'trans') p = Math.round(clampedMouseY * PRECISION_DRAG) / PRECISION_DRAG;
                    else if (g.dragTarget === 'rot') {
                        if(Math.abs(rotX) > 0.01) { m = (clampedMouseY - p) / rotX; }
                        m = Math.round(m * PRECISION_DRAG) / PRECISION_DRAG;
                        if (Math.abs(m) < TOL_M_ZERO) m = 0;
                    } else if (!g.dragTarget) {
                        if (g.isMouseNear(transX, p)) g.dragTarget = 'trans';
                        else if (g.isMouseNear(rotX, m * rotX + p)) g.dragTarget = 'rot';
                    }
                }
                
                // Dessin graphique
                let col = '#333'; 
                if (m > TOL_M_ZERO) col = '#27ae60'; 
                else if (m < -TOL_M_ZERO) col = '#c0392b';
                
                g.drawLine(m, p, col, 3); 
                g.drawPoint(transX, p, '#2980b9'); 
                g.drawPoint(rotX, m * rotX + p, '#8e44ad');
                
                // Mise √† jour des valeurs (rapide)
                divVals.innerHTML = `p = ${p.toFixed(1)} | m = ${m.toFixed(2)}`;
                
                // Logique pour le texte LaTeX 
                let currentState = '';
                let latexCode = '';
                
                if (m > TOL_M_ZERO) {
                    currentState = 'up';
                    latexCode = `\\(\\color{#27ae60}{\\text{La fonction est CROISSANTE sur } ]-\\infty; +\\infty[}\\)`;
                } else if (m < -TOL_M_ZERO) {
                    currentState = 'down';
                    latexCode = `\\(\\color{#c0392b}{\\text{La fonction est D√âCROISSANTE sur } ]-\\infty; +\\infty[}\\)`;
                } else {
                    currentState = 'const';
                    latexCode = `\\(\\color{#333}{\\text{La fonction est CONSTANTE sur } ]-\\infty; +\\infty[}\\)`;
                }

                if (currentState !== lastState) {
                    divText.innerHTML = latexCode;
                    if (window.MathJax) {
                        MathJax.typesetPromise([divText]).catch((err) => console.log(err));
                    }
                    lastState = currentState;
                }
                
                variationTableInstance.draw(m, p);
            });
        }

        // 3. Verticale
        function initVertGraph() {
            const LINE_COLOR = '#e67e22'; 
            
            // Variables d'√©tat
            let c = 3;      // Position de la droite (x = c)
            let ay = 2;     // Hauteur du point A (y variable)
            
            const infoBox = document.getElementById('info-vert');

            new GraphEngine('canvas-vert', (g, mouse) => {
                
                const ax = c; // L'abscisse de A est forc√©e par la droite

                if (g.isDragging) {
                    // Priorit√© 1 : On attrape le point A directement
                    if (g.dragTarget === 'pointA' || (g.dragTarget !== 'line' && g.isMouseNear(ax, ay))) {
                        g.dragTarget = 'pointA';
                        // On met √† jour seulement la hauteur (ay)
                        ay = Math.round(mouse.y * 10) / 10; 
                    } 
                    // Priorit√© 2 : On attrape la droite verticale
                    else if (g.dragTarget === 'line' || (!g.dragTarget && Math.abs(mouse.x - c) < 1)) {
                        g.dragTarget = 'line';
                        // On d√©place la droite (c)
                        c = Math.round(mouse.x * 10) / 10;
                    }
                }
                
                // --- DESSIN ---

                // 1. La droite verticale
                g.drawVerticalLine(c, LINE_COLOR);
                
                // 2. Le point d'ancrage sur l'axe X (pour montrer c)
                g.drawPoint(c, 0, LINE_COLOR, 5); 
                
                // 3. Pointill√©s de A vers l'axe Y (projection)
                g.ctx.save();
                g.ctx.strokeStyle = '#95a5a6';
                g.ctx.lineWidth = 1.5;
                g.ctx.setLineDash([5, 5]); // Cr√©e l'effet pointill√©
                g.ctx.beginPath();
                g.ctx.moveTo(g.toPixelX(ax), g.toPixelY(ay));
                g.ctx.lineTo(g.toPixelX(0), g.toPixelY(ay)); // Vers l'axe Y
                g.ctx.stroke();
                g.ctx.restore();

                // 4. Le Point A (Plus gros pour √™tre attrapable facilement)
                g.drawPoint(ax, ay, LINE_COLOR, 8);

                // 5. Un petit rep√®re sur l'axe Y
                g.drawPoint(0, ay, '#3498db', 4);

                // --- INFO TEXTE ---
                infoBox.innerHTML = `
                    √âquation de la droite : <strong>x = ${c.toFixed(1)}</strong>
                    <br>
                     <span class="highlight-val">Point A(${c.toFixed(1)};${ay.toFixed(1)})</span> 
                `;
            });
        }

        // 4. Point & Droite (Modification pour tol√©rance 0.01 et affichage au dixi√®me)
        function initPointGraph() {
            let m = 0.5; // Slope (pente)
            let p = 1;   // Y-intercept (ordonn√©e √† l'origine)
            let ax = 3, ay = 5; 
            const infoBox = document.getElementById('info-point');

            // Constantes de pr√©cision
            const PRECISION_DRAG = 100; // Arrondi au centi√®me pour le drag
            const TOLERANCE = 0.01; // Tol√©rance pour la v√©rification d'appartenance (centi√®me)
            const DP_DISPLAY = 1; // Nombre de d√©cimales pour l'affichage (dixi√®me)

            // Vider l'infoBox et la pr√©parer pour le contenu MathJax
            infoBox.innerHTML = `<div id="point-info-content">...</div>`;
            const contentDiv = document.getElementById('point-info-content');


            new GraphEngine('canvas-point', (g, mouse) => {
                
                // CONTROL POINTS FOR THE LINE
                const pControlX = 0;
                const pControlY = p;
                const mControlX = 5;
                const mControlY = m * mControlX + p;
                
                if (g.isDragging) {
                    if (g.dragTarget === 'A') { 
                        // Dragging point A (Red/Green)
                        ax = Math.round(mouse.x * PRECISION_DRAG) / PRECISION_DRAG; 
                        ay = Math.round(mouse.y * PRECISION_DRAG) / PRECISION_DRAG; 
                    } else if (g.dragTarget === 'P') {
                        // Dragging point P (Blue - y-intercept)
                        p = Math.round(mouse.y * PRECISION_DRAG) / PRECISION_DRAG;
                    } else if (g.dragTarget === 'M') {
                        // Dragging point M (Purple - slope)
                        if (Math.abs(mouse.x) > 0.01) m = (mouse.y - p) / mouse.x;
                        m = Math.round(m * PRECISION_DRAG) / PRECISION_DRAG;
                    } 
                    // Initial drag target identification
                    else if (!g.dragTarget) {
                        if (g.isMouseNear(ax, ay)) { g.dragTarget = 'A'; }
                        else if (g.isMouseNear(pControlX, pControlY)) { g.dragTarget = 'P'; }
                        else if (g.isMouseNear(mControlX, mControlY)) { g.dragTarget = 'M'; }
                    }
                }
                
                // DRAWING THE LINE
                g.drawLine(m, p, '#bdc3c7', 3);
                
                // DRAWING THE CONTROL POINTS FOR THE LINE
                g.drawPoint(pControlX, p, '#2980b9', 6); 
                g.drawPoint(mControlX, m * mControlX + p, '#8e44ad', 6); 

                // DRAWING POINT A
                const expectedY = m * ax + p; 
                
                // V√âRIFICATION D'APPARTENANCE (Logique : |m*xA + p - yA| < 0.01)
                const isOnLine = Math.abs(expectedY - ay) < TOLERANCE; 
                
                const color = isOnLine ? '#27ae60' : '#c0392b'; 
                g.drawPoint(ax, ay, color, 8);
                
                // --- INFO TEXT (FORMAT AU DIXI√àME) ---
                
                // 1. √âquation de la droite
                let signEq = p >= 0 ? '+' : '';
                let p_display = (p < 0) ? `${p.toFixed(DP_DISPLAY)}` : `+ ${p.toFixed(DP_DISPLAY)}`;
                let lineEquation = `\\(y = ${m.toFixed(DP_DISPLAY)}x ${p_display}\\)`;

                // 2. Calcul m*xA + p = result
                let m_calc = m.toFixed(DP_DISPLAY);
                let ax_calc = ax.toFixed(DP_DISPLAY);
                let p_calc = p.toFixed(DP_DISPLAY);
                let expectedY_calc = expectedY.toFixed(DP_DISPLAY);

                let pCalcDisplay = (p < 0) ? `(${p_calc})` : `+ ${p_calc}`;
                let calculationLine = `\\(\\color{#fff}{\\text{Calcul: }} ${m_calc} \\times ${ax_calc} ${pCalcDisplay} = ${expectedY_calc}\\)`;

                // 3. Comparaison yA = expectedY ou yA \neq expectedY
                let ay_calc = ay.toFixed(DP_DISPLAY);
                let comparisonSymbol = isOnLine ? '=' : '\\neq'; 
                
                // FORMAT DEMAND√â : y_A=<valeur de y_A> [= ou \neq] <valeur de m*x_A+p>
                let comparisonLine = `\\(\\color{#fff}{\\text{V√©rification: }} y_A = ${ay_calc} ${comparisonSymbol} ${expectedY_calc}\\)`;
                
                // 4. Conclusion
                let conclusionColor = isOnLine ? '#27ae60' : '#c0392b';
                let conclusionText = isOnLine 
                    ? `<strong style="color:${conclusionColor}">Le point A(${ax.toFixed(DP_DISPLAY)}; ${ay.toFixed(DP_DISPLAY)}) appartient √† la droite.</strong>` 
                    : `<strong style="color:${conclusionColor}">Le point A(${ax.toFixed(DP_DISPLAY)}; ${ay.toFixed(DP_DISPLAY)}) n'appartient pas √† la droite.</strong>`;

                // Construction du contenu final
                contentDiv.innerHTML = `
                    <p class="info-math">Point A : (${ax.toFixed(DP_DISPLAY)}; ${ay.toFixed(DP_DISPLAY)})</p>
                    <p class="info-math">√âquation : ${lineEquation}</p>
                    <p class="info-math">${calculationLine}</p>
                    <p class="info-math">${comparisonLine}</p>
                    <p>${conclusionText}</p>
                `;

                // D√©clenchement de MathJax
                if (window.MathJax) {
                    MathJax.typesetPromise([contentDiv]).catch((err) => console.log(err));
                }
            });
        }

        // 5. Positions
        function initPosGraph() {
            // Line 1 (Gray)
            let m1 = 0.5, p1 = -1; 
            // Line 2 (Blue)
            let m2 = -2, p2 = 2; 
            const infoBox = document.getElementById('info-pos');

            const x1 = -5; // X-coord for m1 control point
            const x2 = 4;  // X-coord for m2 control point

            new GraphEngine('canvas-pos', (g, mouse) => {
                const PRECISION_DRAG = 100;
                const TOL = 0.01;
                
                const minY = g.toMathY(g.height - 10);
                const maxY = g.toMathY(10);
                let clampedMouseY = Math.min(Math.max(mouse.y, minY), maxY);

                // 3. Control Points coordinates (used for drag detection)
                const p1ControlX = 0;
                const p1ControlY = p1;
                const m1ControlY = m1 * x1 + p1; 
                
                const p2ControlX = 0;
                const p2ControlY = p2;
                const m2ControlY = m2 * x2 + p2; 


                if (g.isDragging) {
                    // LINE 1 (Gray) - Drag Target 'p1' (Translation on Y-axis)
                    if (g.dragTarget === 'p1') {
                        p1 = Math.round(clampedMouseY * PRECISION_DRAG) / PRECISION_DRAG;
                    } 
                    // LINE 1 (Gray) - Drag Target 'm1' (Rotation around p1)
                    else if (g.dragTarget === 'm1') {
                        if (Math.abs(x1) > 0.01) {
                            let newM = (clampedMouseY - p1) / x1;
                            m1 = Math.round(newM * PRECISION_DRAG) / PRECISION_DRAG;
                        }
                    } 
                    // LINE 2 (Blue) - Drag Target 'p2' (Translation on Y-axis)
                    else if (g.dragTarget === 'p2') {
                        p2 = Math.round(clampedMouseY * PRECISION_DRAG) / PRECISION_DRAG;
                    } 
                    // LINE 2 (Blue) - Drag Target 'm2' (Rotation around p2)
                    else if (g.dragTarget === 'm2') {
                        if (Math.abs(x2) > 0.01) {
                            let newM = (clampedMouseY - p2) / x2;
                            m2 = Math.round(newM * PRECISION_DRAG) / PRECISION_DRAG;
                        }
                    } 
                    // Initial drag target identification
                    else if (!g.dragTarget) {
                        if (g.isMouseNear(p1ControlX, p1ControlY)) g.dragTarget = 'p1'; // Translation Gray
                        else if (g.isMouseNear(x1, m1ControlY)) g.dragTarget = 'm1';     // Rotation Gray
                        else if (g.isMouseNear(p2ControlX, p2ControlY)) g.dragTarget = 'p2'; // Translation Blue
                        else if (g.isMouseNear(x2, m2ControlY)) g.dragTarget = 'm2';     // Rotation Blue
                    }
                }
                
                // --- DRAWING ---
                
                // Line 1 (Gray)
                g.drawLine(m1, p1, '#95a5a6', 4); 
                g.drawPoint(p1ControlX, p1ControlY, '#4d5656', 6); // Dark Gray (Translation)
                g.drawPoint(x1, m1 * x1 + p1, '#7f8c8d', 6); // Light Gray (Rotation)

                // Line 2 (Blue)
                g.drawLine(m2, p2, '#3498db', 4); 
                g.drawPoint(p2ControlX, p2ControlY, '#2980b9', 6); // Blue (Translation)
                g.drawPoint(x2, m2 * x2 + p2, '#8e44ad', 6); // Purple (Rotation)


                // --- INFO TEXT ---
                let status = "S√âCANTES"; 
                let color = "#3498db";
                
                const parallel = Math.abs(m1 - m2) < TOL;
                const coincident = parallel && Math.abs(p1 - p2) < TOL;
                const perpendicular = Math.abs(m1 * m2 + 1) < TOL;
                
                if (coincident) {
                    status = "CONFONDUES";
                    color = "#27ae60"; // Green for coincident
                } else if (parallel) { 
                    status = "PARALL√àLES"; 
                    color = "#f1c40f"; 
                } else if (perpendicular) { 
                    status = "PERPENDICULAIRES"; 
                    color = "#e74c3c"; 
                }
                
                infoBox.innerHTML = `
                    (Gris) y = ${m1.toFixed(2)}x ${p1 >= 0 ? '+' : ''} ${p1.toFixed(1)} 
                    <br>
                    (Bleu) y = ${m2.toFixed(2)}x ${p2 >= 0 ? '+' : ''} ${p2.toFixed(1)}
                    <br>
                    <strong style="color:${color}">${status}</strong>
                `;
            });
        }
        
        // 6. Signe de mx+p
        function initSignGraph() {
            let m = 0.5, p = -1; 
            const infoBox = document.getElementById('info-sign');
            
            infoBox.innerHTML = ''; 
            const divVals = document.createElement('div');
            const divText = document.createElement('div');
            divText.style.marginTop = "10px";
            divText.style.minHeight = "40px";
            infoBox.appendChild(divVals);
            infoBox.appendChild(divText);

            let lastState = null;
            const TOL_M_ZERO = 0.1;
            const PRECISION_DRAG = 10;

            const signTableInstance = new SignTable('canvas-sign-table');

            new GraphEngine('canvas-sign', (g, mouse) => {
                
                const minY = g.toMathY(g.height - 10);
                const maxY = g.toMathY(10);
                let clampedMouseY = Math.min(Math.max(mouse.y, minY), maxY);

                const transX = 0; const rotX = 5; 
                
                if (g.isDragging) {
                    if (g.dragTarget === 'trans') p = Math.round(clampedMouseY * PRECISION_DRAG) / PRECISION_DRAG;
                    else if (g.dragTarget === 'rot') {
                        if(Math.abs(rotX) > 0.01) { m = (clampedMouseY - p) / rotX; }
                        m = Math.round(m * PRECISION_DRAG) / PRECISION_DRAG;
                        if (Math.abs(m) < TOL_M_ZERO) m = 0;
                    } else if (!g.dragTarget) {
                        if (g.isMouseNear(transX, p)) g.dragTarget = 'trans';
                        else if (g.isMouseNear(rotX, m * rotX + p)) g.dragTarget = 'rot';
                    }
                }
                
                // --- CALCULS ET DESSIN ---
                
                // 1. Ligne
                g.drawLine(m, p, '#3498db', 3); 
                g.drawPoint(transX, p, '#2980b9'); 
                g.drawPoint(rotX, m * rotX + p, '#8e44ad');
                
                let rootX = NaN;
                let isConstant = false;
                
                if (Math.abs(m) < TOL_M_ZERO) {
                    isConstant = true;
                    // Dessiner une ligne si m est proche de 0
                    if (Math.abs(p) < 0.01) g.drawLine(m, p, '#27ae60', 4); // Ligne sur l'axe X (signe 0)
                    else if (p > 0) g.drawLine(m, p, '#27ae60', 4); // Ligne au-dessus (signe +)
                    else g.drawLine(m, p, '#c0392b', 4); // Ligne en-dessous (signe -)
                } else {
                    rootX = -p / m;
                    // 2. Point Racine (sur l'axe X)
                    g.drawPoint(rootX, 0, '#f1c40f', 8); 
                }


                // --- MISE A JOUR DU TEXTE ET DU TABLEAU ---
                
                // MODIFICATION: Affichage de l'expression compl√®te en LaTeX
                let p_display = (p < 0) ? `${p.toFixed(1)}` : `+ ${p.toFixed(1)}`;
                let m_display = m.toFixed(2);
                
                // CORRECTION MathJax : Suppression de \color{#fff} et utilisation d'un span pour la couleur
                let rootInfo = !isConstant ? `<span style="color:white">f(x) = 0  pour  x = ${rootX.toFixed(2)}</span>` : '';
                divVals.innerHTML = `<span style="color:white">y=${m_display}x ${p_display}</span><br>${rootInfo}`;
                

                let currentState = '';
                let latexCode = '';

                if (isConstant) {
                    // M=0
                    if (Math.abs(p) < 0.01) {
                         currentState = 'zero';
                         latexCode = `\\(\\text{Cas } m=0 \\text{ et } p=0: f(x)=0.\\text{ Signe constant } 0.\\)`;
                         divText.style.color = 'white'; // Texte d√©j√† blanc sur fond bleu/noir
                    } else if (p > 0) {
                        currentState = 'const_pos';
                        latexCode = `\\(\\color{#27ae60}{\\text{Cas } m=0 \\text{ et } p>0: f(x)=p.\\text{ Signe constant } +}\\)`;
                        divText.style.color = '#27ae60'; // Texte vert
                    } else {
                        currentState = 'const_neg';
                        latexCode = `\\(\\color{red}{\\text{Cas } m=0 \\text{ et } p<0: f(x)=p.\\text{ Signe constant } -}\\)`;
                        divText.style.color = 'red'; // Texte rouge
                    }
                } else {
                    // M!=0
                    currentState = m > 0 ? 'root_up' : 'root_down';
                    let x0_display = rootX.toFixed(2);
                    let inequality = m > 0 ? `\\(< 0 \\text{ pour } x < x_0\\)` : `\\(> 0 \\text{ pour } x < x_0\\)`;
                    
                    // CORRECTION MathJax : Suppression de \color{#fff} et utilisation d'un span pour la couleur
                    latexCode = `<span style="color:white">\\(\\text{Racine } x_0 = ${x0_display}\\). f(x) ${inequality}</span>`;
                    divText.style.color = 'white';
                }

                if (currentState !== lastState) {
                    // Pour les cas m!=0, on enl√®ve le texte du span car on l'a d√©j√† mis dans latexCode
                    if (!isConstant) {
                         divText.innerHTML = latexCode;
                    } else {
                         // Pour les cas m=0, on peut garder la couleur MathJax car c'est un nom standard
                         divText.innerHTML = latexCode;
                    }

                    if (window.MathJax) {
                        MathJax.typesetPromise([divText, divVals]).catch((err) => console.log(err));
                    }
                    lastState = currentState;
                }
                
                signTableInstance.draw(m, p);
            });
        }

	// --- GESTION DES M√âTHODES DE CALCUL (NOUVELLE SECTION) ---

        function switchMethod(methodId) {
            // Gestion de l'affichage des onglets
            document.querySelectorAll('.method-container').forEach(el => el.classList.remove('active'));
            document.getElementById('method-' + methodId).classList.add('active');
            
            document.querySelectorAll('.sub-nav-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');

            // Initialisation des graphiques si n√©cessaire
            if (methodId === 'A') generateRandomGraphA();
            if (methodId === 'B') generateRandomGraphB();
        }

        // Cas A : Graphique 2 points entiers
        function generateRandomGraphA() {
            // G√©n√©ration al√©atoire de points entiers pour faciliter la lecture
            let x1 = Math.floor(Math.random() * 6) - 3; // entre -3 et 2
            let x2 = x1 + Math.floor(Math.random() * 3) + 2; // x2 > x1
            let y1 = Math.floor(Math.random() * 8) - 4;
            let y2 = Math.floor(Math.random() * 8) - 4;
            
            // √âviter une pente nulle pour l'exercice
            if (y1 === y2) y2++;

            const m = (y2 - y1) / (x2 - x1);
            const p = y1 - m * x1;

            new GraphEngine('canvas-method-a', (g) => {
                // Dessin de la droite
                g.drawLine(m, p, '#2c3e50', 3);

                // Mise en √©vidence des deux points
                g.drawPoint(x1, y1, '#e74c3c');
                g.drawPoint(x2, y2, '#e74c3c');

                // Pointill√©s de lecture
                g.ctx.setLineDash([5, 5]);
                g.ctx.strokeStyle = '#7f8c8d';
                // Point A
                g.ctx.beginPath(); g.ctx.moveTo(g.toPixelX(x1), g.toPixelY(0)); g.ctx.lineTo(g.toPixelX(x1), g.toPixelY(y1)); g.ctx.lineTo(g.toPixelX(0), g.toPixelY(y1)); g.ctx.stroke();
                // Point B
                g.ctx.beginPath(); g.ctx.moveTo(g.toPixelX(x2), g.toPixelY(0)); g.ctx.lineTo(g.toPixelX(x2), g.toPixelY(y2)); g.ctx.lineTo(g.toPixelX(0), g.toPixelY(y2)); g.ctx.stroke();
                g.ctx.setLineDash([]);

                // Triangle de pente (optionnel mais utile)
                g.ctx.strokeStyle = '#27ae60'; g.ctx.lineWidth = 2;
                g.ctx.beginPath();
                g.ctx.moveTo(g.toPixelX(x1), g.toPixelY(y1));
                g.ctx.lineTo(g.toPixelX(x2), g.toPixelY(y1)); // Horizontal
                g.ctx.lineTo(g.toPixelX(x2), g.toPixelY(y2)); // Vertical
                g.ctx.stroke();
            });

            // Affichage de la solution
            const info = document.getElementById('info-method-a');
            info.innerHTML = `
                <div style="text-align:left">
                <strong>Lecture :</strong><br>
                \\( A(${x1}; ${y1}) \\) et \\( B(${x2}; ${y2}) \\)<br><br>
                <strong>Calcul de m :</strong><br>
                \\( m = \\dfrac{y_B - y_A}{x_B - x_A} = \\dfrac{${y2} - (${y1})}{${x2} - (${x1})} = \\dfrac{${y2-y1}}{${x2-x1}} \\) 
                ${Number.isInteger(m) ? `= ${m}` : ` <br>Penser √† simplifier (Si besoin)`}
                </div>
            `;
            if(window.MathJax) MathJax.typesetPromise([info]);
        }

        // Cas B : Graphique m et p simples
        function generateRandomGraphB() {
            // p entier, m simple (0.5, 1, -1, -2, etc.)
            let p = Math.floor(Math.random() * 6) - 3;
            let mCandidates = [1, -1, 2, -2, 0.5, -0.5];
            let m = mCandidates[Math.floor(Math.random() * mCandidates.length)];

            new GraphEngine('canvas-method-b', (g) => {
                g.drawLine(m, p, '#8e44ad', 3);

                // 1. Point P (Ordonn√©e √† l'origine)
                g.drawPoint(0, p, '#f1c40f', 8); // Jaune gros point

                // 2. D√©placement de 1 unit√© √† droite
                g.ctx.beginPath(); g.ctx.strokeStyle = '#27ae60'; g.ctx.lineWidth = 3;
                g.ctx.moveTo(g.toPixelX(0), g.toPixelY(p));
                g.ctx.lineTo(g.toPixelX(1), g.toPixelY(p)); // Fl√®che droite
                g.ctx.stroke();

                // 3. Mont√©e/Descente m
                g.ctx.beginPath(); g.ctx.strokeStyle = '#e74c3c';
                g.ctx.moveTo(g.toPixelX(1), g.toPixelY(p));
                g.ctx.lineTo(g.toPixelX(1), g.toPixelY(p + m)); // Fl√®che verticale
                g.ctx.stroke();

                // Point d'arriv√©e
                g.drawPoint(1, p + m, '#2c3e50', 4);
            });

            const info = document.getElementById('info-method-b');
            info.innerHTML = `
                <div style="text-align:left">
                1. On lit <strong>p = ${p}</strong> (intersection axe vertical).<br>
                2. On avance de 1 (trait vert).<br>
                3. On monte/descend de <strong>${m}</strong> (trait rouge).<br>
                D'o√π \( m = ${m} \).<br>
                √âquation : \( y = ${m}x + (${p}) \)
                </div>
            `;
            if(window.MathJax) MathJax.typesetPromise([info]);
        }

        // Cas C : Calcul 2 points
        // Cas C : 2 Points (Version Interactive)
        function calcModeC() {
            const res = document.getElementById('res-method-c');
            res.innerHTML = "";

            // 1. R√©cup√©ration des coordonn√©es
            const xA = parseFloat(document.getElementById('cxA').value);
            const yA = parseFloat(document.getElementById('cyA').value);
            const xB = parseFloat(document.getElementById('cxB').value);
            const yB = parseFloat(document.getElementById('cyB').value);

            if ([xA, yA, xB, yB].some(isNaN)) {
                res.innerHTML = "‚ö†Ô∏è Veuillez d'abord d√©finir les coordonn√©es des points A et B (√âtape 1).";
                return;
            }
            if (xA === xB) {
                res.innerHTML = "‚ö†Ô∏è Droite Verticale (x = " + xA + "). Le coefficient directeur m n'est pas d√©fini (division par z√©ro).";
                return;
            }

            // Calculs r√©els pour v√©rification
            const real_m = (yB - yA) / (xB - xA);
            const real_p = yA - real_m * xA;

            // 2. V√©rification des inputs de m
            const in_yB = parseFloat(document.getElementById('in_yB').value);
            const in_yA = parseFloat(document.getElementById('in_yA').value);
            const in_xB = parseFloat(document.getElementById('in_xB').value);
            const in_xA = parseFloat(document.getElementById('in_xA').value);

            let errors = [];
            // On v√©rifie strictement la position des valeurs selon la formule (yB - yA) / (xB - xA)
            if (in_yB !== yB) errors.push("Dans m : La valeur yB est incorrecte.");
            if (in_yA !== yA) errors.push("Dans m : La valeur yA est incorrecte.");
            if (in_xB !== xB) errors.push("Dans m : La valeur xB est incorrecte.");
            if (in_xA !== xA) errors.push("Dans m : La valeur xA est incorrecte.");

            if (errors.length > 0) {
                res.innerHTML = "‚ö†Ô∏è <strong>Erreurs dans la formule de m :</strong><br>" + errors.join("<br>");
                return;
            }

            // 3. V√©rification des inputs de p
            // p = yA - m * xA
            const in_p_yA = parseFloat(document.getElementById('in_p_yA').value);
            const in_p_m  = parseFloat(document.getElementById('in_p_m').value);
            const in_p_xA = parseFloat(document.getElementById('in_p_xA').value);

            if (in_p_yA !== yA) errors.push("Dans p : La valeur yA est incorrecte.");
            if (in_p_xA !== xA) errors.push("Dans p : La valeur xA est incorrecte.");
            
            // Pour m, on accepte une petite marge d'erreur (arrondi)
            if (isNaN(in_p_m) || Math.abs(in_p_m - real_m) > 0.01) {
                errors.push("Dans p : La valeur de m est incorrecte. (Avez-vous bien calcul√© m ?)");
            }

            if (errors.length > 0) {
                res.innerHTML = "‚ö†Ô∏è <strong>Erreurs dans la formule de p :</strong><br>" + errors.join("<br>");
                return;
            }

            // Si tout est bon
            res.innerHTML = `
                <div style="background: rgba(39, 174, 96, 0.2); padding: 10px; border-radius: 5px; margin-bottom: 10px;">
                    ‚úÖ <strong>Bravo !</strong> Vos substitutions sont correctes.
                </div>
                <div>
                    R√©sultats calcul√©s :<br>
                    $$ m = ${parseFloat(real_m.toFixed(4))} $$
                    $$ p = ${parseFloat(real_p.toFixed(4))} $$
                    <span class="highlight-val" style="font-size:1.2rem">√âquation : y = ${parseFloat(real_m.toFixed(4))}x + ${parseFloat(real_p.toFixed(4))}</span>
                </div>
            `;
            MathJax.typesetPromise([res]);
        }

        // Cas D : Point et m
        // Cas D : Point et m (Version Interactive)
        function calcModeD() {
            const res = document.getElementById('res-method-d');
            res.innerHTML = "";

            // 1. R√©cup√©ration des donn√©es initiales (√âtape 1)
            const xA = parseFloat(document.getElementById('dxA').value);
            const yA = parseFloat(document.getElementById('dyA').value);
            const m = parseFloat(document.getElementById('dm').value);

            if (isNaN(xA) || isNaN(yA) || isNaN(m)) {
                res.innerHTML = "‚ö†Ô∏è Veuillez d'abord d√©finir le point A et le coefficient m (√âtape 1).";
                return;
            }

            // Calcul r√©el pour v√©rification
            const real_p = yA - m * xA;

            // 2. V√©rification des inputs de substitution (√âtape 2)
            const in_yA = parseFloat(document.getElementById('in_d_yA').value);
            const in_m = parseFloat(document.getElementById('in_d_m').value);
            const in_xA = parseFloat(document.getElementById('in_d_xA').value);

            let errors = [];
            
            // Formule : p = yA - m * xA
            if (in_yA !== yA) errors.push("La valeur plac√©e pour yA est incorrecte.");
            if (in_m !== m) errors.push("La valeur plac√©e pour m est incorrecte.");
            if (in_xA !== xA) errors.push("La valeur plac√©e pour xA est incorrecte.");

            if (errors.length > 0) {
                res.innerHTML = "‚ö†Ô∏è <strong>Erreurs dans la substitution :</strong><br>" + errors.join("<br>");
                return;
            }

            // Si tout est bon
            // Affichage propre du signe pour l'√©quation finale
            const signP = real_p >= 0 ? "+ " : ""; 
            
            res.innerHTML = `
                <div style="background: rgba(39, 174, 96, 0.2); padding: 10px; border-radius: 5px; margin-bottom: 10px;">
                    ‚úÖ <strong>Bravo !</strong> Vos substitutions sont correctes.
                </div>
                <div>
                    Calcul :<br>
                    $$ p = ${yA} - (${m} \\times ${xA}) = ${parseFloat(real_p.toFixed(4))} $$
                    <span class="highlight-val" style="font-size:1.2rem">√âquation : y = ${m}x ${signP}${parseFloat(real_p.toFixed(4))}</span>
                </div>
            `;
            MathJax.typesetPromise([res]);
        }

        // Cas E : Point et p
        // Cas E : Point et p (Version Interactive)
        function calcModeE() {
            const res = document.getElementById('res-method-e');
            res.innerHTML = "";

            // 1. R√©cup√©ration des donn√©es initiales (√âtape 1)
            const xA = parseFloat(document.getElementById('exA').value);
            const yA = parseFloat(document.getElementById('eyA').value);
            const p = parseFloat(document.getElementById('ep').value);

            if (isNaN(xA) || isNaN(yA) || isNaN(p)) {
                res.innerHTML = "‚ö†Ô∏è Veuillez d'abord d√©finir le point A et l'ordonn√©e √† l'origine p (√âtape 1).";
                return;
            }
            
            // Gestion du cas xA = 0 (division par z√©ro impossible pour calculer m)
            if (xA === 0) {
                 if (yA === p) res.innerHTML = "‚ö†Ô∏è Le point est sur l'axe des ordonn√©es (0, p). m peut √™tre n'importe quel r√©el (infinit√© de droites).";
                 else res.innerHTML = "‚ö†Ô∏è Impossible : Un point d'abscisse 0 ne peut pas avoir une ordonn√©e diff√©rente de p (l'ordonn√©e √† l'origine).";
                 return;
            }

            // Calcul r√©el pour v√©rification
            const real_m = (yA - p) / xA;

            // 2. V√©rification des inputs de substitution (√âtape 2)
            const in_yA = parseFloat(document.getElementById('in_e_yA').value);
            const in_p = parseFloat(document.getElementById('in_e_p').value);
            const in_xA = parseFloat(document.getElementById('in_e_xA').value);

            let errors = [];
            
            // Formule : m = (yA - p) / xA
            if (in_yA !== yA) errors.push("La valeur plac√©e pour yA est incorrecte.");
            if (in_p !== p) errors.push("La valeur plac√©e pour p est incorrecte.");
            if (in_xA !== xA) errors.push("La valeur plac√©e pour xA est incorrecte.");

            if (errors.length > 0) {
                res.innerHTML = "‚ö†Ô∏è <strong>Erreurs dans la substitution :</strong><br>" + errors.join("<br>");
                return;
            }

            // Si tout est bon
            const signP = p >= 0 ? "+ " : ""; 
            
            res.innerHTML = `
                <div style="background: rgba(39, 174, 96, 0.2); padding: 10px; border-radius: 5px; margin-bottom: 10px;">
                    ‚úÖ <strong>Bravo !</strong> Vos substitutions sont correctes.
                </div>
                <div>
                    Calcul :<br>
                    $$ m = \\dfrac{${yA} - ${p}}{${xA}} = ${parseFloat(real_m.toFixed(4))} $$
                    <span class="highlight-val" style="font-size:1.2rem">√âquation : y = ${parseFloat(real_m.toFixed(4))}x ${signP}${p}</span>
                </div>
            `;
            MathJax.typesetPromise([res]);
        }
        // --- Gestion de la fen√™tre Droits d'Auteur ---
        const modal = document.getElementById("copyright-modal");
        const btn = document.getElementById("copyright-btn");
        const span = document.getElementsByClassName("close-modal")[0];

        // Ouvrir la modale au clic sur le bouton
        btn.onclick = function() {
            modal.style.display = "block";
        }

        // Fermer la modale au clic sur la croix
        span.onclick = function() {
            modal.style.display = "none";
        }

        // Fermer la modale si on clique en dehors du contenu
        window.onclick = function(event) {
            if (event.target == modal) {
                modal.style.display = "none";
            }
        }
	/* --- LOGIQUE DES EXERCICES (Fusionn√©e) --- */

let currentType = 'belong';
let currentData = {};

// Initialisation de l'onglet (appel√© par le bouton du menu)
function initExos() {
    // Si la zone est vide (premier chargement), on lance le premier exercice
    if(document.getElementById('exercise-area').innerHTML.includes('S√©lectionnez')) {
        loadExercise('belong');
    }
}

function toggleDisplay(id) {
    const el = document.getElementById(id);
    el.style.display = (el.style.display === 'block') ? 'none' : 'block';
}

// Classe Fraction pour les calculs exacts
function pgcd(a, b) { return b === 0 ? a : pgcd(b, a % b); }
class Fraction {
    constructor(n, d = 1) {
        if (d < 0) { n = -n; d = -d; }
        this.n = n; this.d = d;
    }
    simplify() {
        let div = Math.abs(pgcd(this.n, this.d));
        return new Fraction(this.n / div, this.d / div);
    }
    add(other) { return new Fraction(this.n * other.d + other.n * this.d, this.d * other.d).simplify(); }
    sub(other) { return new Fraction(this.n * other.d - other.n * this.d, this.d * other.d).simplify(); }
    mult(other) { return new Fraction(this.n * other.n, this.d * other.d).simplify(); }
    div(other) { return new Fraction(this.n * other.d, this.d * other.n).simplify(); }
    toTex() { return this.d === 1 ? `${this.n}` : `\\dfrac{${this.n}}{${this.d}}`; }
}

// Utilitaires
const rand = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
const randNonZero = (min, max) => { let r = 0; while(r===0) r = rand(min, max); return r; };
const fmt = (x) => x < 0 ? `(${x})` : `${x}`;
// --- FONCTION UTILITAIRE POUR DESSINER LES GRAPHIQUES "SOLVER" (√âchelle dynamique) ---
function drawSolverGraph(canvasId, a, b, c, xSolution, isPercent) {
    const canvas = document.getElementById(canvasId);
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width;
    const H = canvas.height;
    const MARGIN = 40;

    // Calcul des √©chelles dynamiques
    let xMax = Math.max(xSolution * 1.2, isPercent ? 100 : 10);
    let yMax = Math.max(Math.max(b, c) * 1.2, 10);
    let xMin = isPercent ? 0 : -5;
    let yMin = isPercent ? 0 : Math.min(0, b - 5);

    // Fonction de conversion
    const mapX = (x) => MARGIN + (x - xMin) / (xMax - xMin) * (W - 2 * MARGIN);
    const mapY = (y) => H - MARGIN - (y - yMin) / (yMax - yMin) * (H - 2 * MARGIN);

    ctx.clearRect(0, 0, W, H);

    // Axes
    ctx.strokeStyle = '#333'; ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(MARGIN, mapY(0)); ctx.lineTo(W - MARGIN, mapY(0)); // Axe X
    ctx.moveTo(mapX(0), H - MARGIN); ctx.lineTo(mapX(0), MARGIN); // Axe Y
    ctx.stroke();

    // Fonction f(x) = ax + b (Rouge)
    ctx.strokeStyle = '#e74c3c'; ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(mapX(xMin), mapY(a * xMin + b));
    ctx.lineTo(mapX(xMax), mapY(a * xMax + b));
    ctx.stroke();

    // Cible y = c (Vert pointill√©)
    ctx.strokeStyle = '#27ae60'; ctx.setLineDash([5, 5]);
    ctx.beginPath();
    ctx.moveTo(MARGIN, mapY(c)); ctx.lineTo(W - MARGIN, mapY(c));
    ctx.stroke();

    // Solution (Bleu vertical)
    ctx.strokeStyle = '#3498db';
    ctx.beginPath();
    ctx.moveTo(mapX(xSolution), mapY(c)); ctx.lineTo(mapX(xSolution), mapY(0));
    ctx.stroke();
    ctx.setLineDash([]);

    // Point intersection
    ctx.fillStyle = '#3498db';
    ctx.beginPath(); ctx.arc(mapX(xSolution), mapY(c), 6, 0, Math.PI * 2); ctx.fill();

    // Textes
    ctx.fillStyle = '#333'; ctx.font = "14px Arial";
    ctx.textAlign = "right"; ctx.fillText(`Target: ${c.toFixed(0)}`, W - 50, mapY(c) - 10);
    ctx.textAlign = "center"; ctx.fillText(`Solution: x ‚âà ${xSolution.toFixed(2)}`, mapX(xSolution), mapY(0) + 20);
}
// Moteur principal des exercices
function loadExercise(type) {
    currentType = type;
    const area = document.getElementById('exercise-area');
    const tags = document.getElementById('help-tags');
    const help = document.getElementById('help-content');
    const sol = document.getElementById('solution-content');
    
    // Reset affichage
    document.getElementById('help-area').style.display = 'none';
    document.getElementById('sol-area').style.display = 'none';
    help.innerHTML = "";
    
    let data = {};
    
    // G√©n√©ration selon le type
    if (type === 'belong') {
        const m = randNonZero(-4, 4);
        const p = rand(-5, 5);
        const xA = rand(-5, 5);
        // 50% de chance d'√™tre sur la droite
        const isOnLine = Math.random() > 0.5;
        const yA = isOnLine ? (m * xA + p) : (m * xA + p + randNonZero(-3, 3));
        
        data = { m, p, xA, yA, isOnLine };
        
        area.innerHTML = `Soit la droite \\( (d) \\) d'√©quation \\( y = ${m}x ${p>=0?'+':''} ${p} \\).<br> Le point \\( A(${xA}; ${yA}) \\) appartient-il √† la droite ?`;
        
        tags.innerHTML = `<span class="tag-helper" onclick="showHint('subst')">M√©thode</span>`;
        
        const calcVal = m * xA + p;
        sol.innerHTML = `
            <div class="step-detail">1. On remplace \\( x \\) par \\( x_A = ${xA} \\) dans l'√©quation.</div>
            <div class="step-detail">\\( ${m} \\times ${fmt(xA)} ${p>=0?'+':''} ${p} = ${m*xA} ${p>=0?'+':''} ${p} = ${calcVal} \\)</div>
            <div class="step-detail">2. On compare avec \\( y_A = ${yA} \\).</div>
            <div class="highlight">${calcVal === yA ? '‚úÖ Les valeurs sont √©gales, A appartient √† la droite.' : '‚ùå Les valeurs sont diff√©rentes, A n\'appartient pas √† la droite.'}</div>
        `;
    } 
    else if (type === 'calc_m') {
        const xA = rand(-5, 5);
        let xB = xA; while(xB === xA) xB = rand(-5, 5);
        const yA = rand(-5, 5);
        const yB = rand(-5, 5);
        
        area.innerHTML = `Calculer le coefficient directeur \\( m \\) de la droite passant par \\( A(${xA}; ${yA}) \\) et \\( B(${xB}; ${yB}) \\).`;
        tags.innerHTML = `<span class="tag-helper" onclick="showHint('form_m')">Formule de m</span> <span class="tag-helper" onclick="showHint('signes')">R√®gle des signes</span>`;
        
        const num = yB - yA;
        const den = xB - xA;
        const mFrac = new Fraction(num, den).simplify();
        
        sol.innerHTML = `
            <div class="step-detail">Formule : \\( m = \\dfrac{y_B - y_A}{x_B - x_A} \\)</div>
            <div class="step-detail">Application : \\( m = \\dfrac{${yB} - ${fmt(yA)}}{${xB} - ${fmt(xA)}} = \\dfrac{${num}}{${den}} \\)</div>
            <div class="highlight">R√©sultat : \\( m = ${mFrac.toTex()} \\)</div>
        `;
    }
    else if (type === 'eq_2pts') {
        const xA = rand(-4, 4); const yA = rand(-4, 4);
        let xB = xA; while(xB === xA) xB = rand(-4, 4);
        const yB = rand(-4, 4);
        
        area.innerHTML = `D√©terminer l'√©quation de la droite passant par \\( A(${xA}; ${yA}) \\) et \\( B(${xB}; ${yB}) \\).`;
        tags.innerHTML = `<span class="tag-helper" onclick="showHint('form_m')">1. Calculer m</span> <span class="tag-helper" onclick="showHint('form_p_from_m')">2. Calculer p</span>`;
        
        const num = yB - yA; const den = xB - xA;
        const mFrac = new Fraction(num, den).simplify();
        // p = yA - m*xA
        const pFrac = new Fraction(yA, 1).sub(mFrac.mult(new Fraction(xA, 1)));
        
        sol.innerHTML = `
            <div class="step-detail">1. Calcul de m : \\( m = \\dfrac{${yB}-${fmt(yA)}}{${xB}-${fmt(xA)}} = ${mFrac.toTex()} \\)</div>
            <div class="step-detail">2. Calcul de p avec le point A : \\( p = y_A - m \\times x_A \\)</div>
            <div class="step-detail">\\( p = ${yA} - ${mFrac.toTex()} \\times ${fmt(xA)} = ${pFrac.toTex()} \\)</div>
            <div class="highlight">√âquation : \\( y = ${mFrac.toTex()}x ${pFrac.n >= 0 ? '+' : ''} ${pFrac.toTex()} \\)</div>
        `;
    }
    else if (type === 'point_et_p'){
        // G√©n√©ration al√©atoire : Point A (xA, yA) et ordonn√©e √† l'origine p
        const xA_pp = randNonZero(-8, 8); // xA ne doit pas √™tre nul
        const yA_pp = rand(-8, 8);
        const p_pp = rand(-5, 5);

        // Affichage de l'√©nonc√©
        area.innerHTML = `D√©terminer l'√©quation r√©duite de la droite passant par le point \\( A(${xA_pp}; ${yA_pp}) \\) et dont l'ordonn√©e √† l'origine est \\( p = ${p_pp} \\). `;

        // Boutons d'aide
        tags.innerHTML = `
            <span class="tag-helper" onclick="showHint('rappel_eq')">Forme de l'√©quation</span>
            <span class="tag-helper" onclick="showHint('isol_m')">Comment trouver m ?</span>
        `;

        // Calcul de la solution
        // m = (yA - p) / xA
        const num_pp = yA_pp - p_pp;
        const den_pp = xA_pp;
        const mFrac_pp = new Fraction(num_pp, den_pp).simplify();
        const pFrac_pp = new Fraction(p_pp, 1); // Pour affichage uniforme si besoin, sinon p_pp suffit

        // Construction de la solution HTML
        sol.innerHTML = `
            <div class="step-detail">1. L'√©quation r√©duite est de la forme \\( y = mx + p \\).</div>
            <div class="step-detail">L'√©nonc√© donne directement l'ordonn√©e √† l'origine : \\( p = ${p_pp} \\).</div>
            <div class="step-detail">2. La droite passe par \\( A(${xA_pp}; ${yA_pp}) \\). Ses coordonn√©es v√©rifient donc l'√©quation :</div>
            <div class="step-detail" style="text-align:center">\\( y_A = m \\times x_A + p \\)</div>
            <div class="step-detail" style="text-align:center">\\( ${yA_pp} = m \\times ${fmt(xA_pp)} + ${fmt(p_pp)} \\)</div>
            <div class="step-detail">3. On isole \\( m \\) :</div>
            <div class="step-detail" style="text-align:center">\\( m \\times ${fmt(xA_pp)} = ${yA_pp} - ${fmt(p_pp)} \\)</div>
            <div class="step-detail" style="text-align:center">\\( m = \\dfrac{${yA_pp} - ${fmt(p_pp)}}{${xA_pp}} = \\dfrac{${yA_pp - p_pp}}{${xA_pp}} = ${mFrac_pp.toTex()} \\)</div>
            <div class="highlight">√âquation finale : \\( y = ${mFrac_pp.toTex()}x ${p_pp >= 0 ? '+' : ''} ${p_pp} \\)</div>
        `;}
    	else if (type === 'point_et_m'){
             // G√©n√©ration : Point A (xA, yA) et coefficient directeur m
                  const xA_pm = randNonZero(-8, 8);
                  const yA_pm = rand(-8, 8);
        	  const m_pm = randNonZero(-5, 5); // m entier pour cet exercice

        	  // Enonc√©
        	  area.innerHTML = `D√©terminer l'√©quation r√©duite de la droite passant par le point \\( A(${xA_pm}; ${yA_pm}) \\) et dont le coefficient directeur est \\( m = ${m_pm} \\).`;

        // Boutons d'aide
        tags.innerHTML = `
            <span class="tag-helper" onclick="showHint('rappel_forme_m')">Forme de l'√©quation</span>
            <span class="tag-helper" onclick="showHint('calc_p_from_m')">Comment trouver p ?</span>
        `;

        // Calcul de la solution
        // p = yA - (m * xA)
        const produit_m_x = m_pm * xA_pm;
        const p_val = yA_pm - produit_m_x;
        
        // Cr√©ation d'objets Fraction pour un affichage uniforme (si vous utilisez la classe Fraction du fichier)
        const mFrac_pm = new Fraction(m_pm, 1);
        const pFrac_pm = new Fraction(p_val, 1);

        // Solution HTML
        sol.innerHTML = `
            <div class="step-detail">1. L'√©quation r√©duite est de la forme \\( y = mx + p \\).</div>
            <div class="step-detail">L'√©nonc√© donne le coefficient directeur : \\( m = ${m_pm} \\).</div>
            <div class="step-detail">L'√©quation s'√©crit donc partiellement : \\( y = ${mFrac_pm.toTex()}x + p \\).</div>
            
            <div class="step-detail">2. La droite passe par \\( A(${xA_pm}; ${yA_pm}) \\). Ses coordonn√©es v√©rifient l'√©quation :</div>
            <div class="step-detail" style="text-align:center">\\( y_A = m \\times x_A + p \\)</div>
            <div class="step-detail" style="text-align:center">\\( ${yA_pm} = ${m_pm} \\times ${fmt(xA_pm)} + p \\)</div>
            
            <div class="step-detail">3. On isole \\( p \\) :</div>
            <div class="step-detail" style="text-align:center">\\( p = ${yA_pm} - ( ${m_pm} \\times ${fmt(xA_pm)} ) \\)</div>
            <div class="step-detail" style="text-align:center">\\( p = ${yA_pm} - ( ${produit_m_x} ) = ${p_val} \\)</div>
            
            <div class="highlight">√âquation finale : \\( y = ${mFrac_pm.toTex()}x ${p_val >= 0 ? '+' : ''} ${pFrac_pm.toTex()} \\)</div>
        `;}
	else if (type === 'lecture_graphique') {
        // --- 1. G√âN√âRATION AL√âATOIRE ---
        const m_lg = randNonZero(-3, 3);
        const p_lg = rand(-4, 4); 

        // On d√©termine si on demande l'√©quation ou une image
        const questionType = 1; // On force le type "Trouver l'√©quation" pour cet exemple d√©taill√©
        
        // Identifiants uniques pour les canvas
        const canvasExoId = 'canvas-exo-' + Date.now();
        const canvasSolId = 'canvas-sol-' + Date.now();

        // --- 2. AFFICHAGE DE L'√âNONC√â ---
        area.innerHTML = `
            <div class="exercise-box">
                <p>D√©terminer l'√©quation r√©duite de la droite \\( d \\) repr√©sent√©e ci-dessous.</p>
                <div class="canvas-container">
                    <canvas id="${canvasExoId}" width="450" height="300"></canvas>
                </div>
            </div>
        `;
        
        tags.innerHTML = `
            <span class="tag-helper" onclick="showHint('rappel_eq')">Forme de l'√©quation</span>
            <span class="tag-helper" onclick="showHint('lecture_p')">Aide pour p</span>
            <span class="tag-helper" onclick="showHint('lecture_m')">Aide pour m</span>
        `;

        // --- 3. AFFICHAGE DE LA SOLUTION D√âTAILL√âE ---
        sol.innerHTML = `
            <div style="border-left: 4px solid #e67e22; padding-left: 10px; margin-bottom: 15px;">
                <h4 style="margin:0; color:#d35400;">√âtape 1 : Trouver p (Ordonn√©e √† l'origine)</h4>
                <p class="step-detail">On regarde o√π la droite coupe l'axe vertical (l'axe des y).</p>
                <p class="step-detail">Ici, l'intersection est au point <strong style="color:#e67e22">(0 ; ${p_lg})</strong>.</p>
                <p class="step-detail">Donc <strong>p = ${p_lg}</strong>.</p>
            </div>

            <div style="border-left: 4px solid #c0392b; padding-left: 10px; margin-bottom: 15px;">
                <h4 style="margin:0; color:#c0392b;">√âtape 2 : Trouver m (Coefficient directeur)</h4>
                <p class="step-detail">Partant du point \\( p \\), on avance de <strong>1 carreau vers la droite</strong> (trait vert).</p>
                <p class="step-detail">Ensuite, on compte de combien on doit monter ou descendre pour retrouver la droite (trait rouge).</p>
                <p class="step-detail">Ici, on ${m_lg > 0 ? 'monte' : 'descend'} de <strong>${Math.abs(m_lg)}</strong> unit√©(s).</p>
                <p class="step-detail">Donc <strong>m = ${m_lg}</strong>.</p>
            </div>

            <div class="canvas-container" style="background:#fff3e0; border:1px solid #e67e22;">
                <canvas id="${canvasSolId}" width="450" height="300"></canvas>
                <div style="font-size:0.9rem; color:#d35400; font-style:italic; margin-top:5px;">Illustration de la lecture graphique</div>
            </div>

            <div class="highlight" style="margin-top:20px; text-align:center; font-size:1.3rem;">
                Conclusion : \\( y = ${m_lg}x ${p_lg >= 0 ? '+' : ''} ${p_lg} \\)
            </div>
        `;

        // --- 4. DESSIN DES GRAPHIQUES (√ânonc√© & Correction) ---
        setTimeout(() => {
            // A. Graphique de l'√ânonc√© (Juste la droite)
            if(document.getElementById(canvasExoId)) {
                new GraphEngine(canvasExoId, (g) => {
                    g.drawLine(m_lg, p_lg, '#A00000', 3);
                });
            }

            // B. Graphique de la Solution (D√©tails color√©s)
            if(document.getElementById(canvasSolId)) {
                new GraphEngine(canvasSolId, (g) => {
                    // 1. La droite en transparence
                    g.drawLine(m_lg, p_lg, 'rgba(44, 62, 80, 0.3)', 2);

                    // 2. Le point P (Orange)
                    g.drawPoint(0, p_lg, '#e67e22', 7); 
                    
                    // 3. Le d√©placement horizontal (+1) (Vert)
                    g.ctx.beginPath(); 
                    g.ctx.strokeStyle = '#27ae60'; g.ctx.lineWidth = 4;
                    g.ctx.moveTo(g.toPixelX(0), g.toPixelY(p_lg));
                    g.ctx.lineTo(g.toPixelX(1), g.toPixelY(p_lg)); 
                    g.ctx.stroke();

                    // 4. Le d√©placement vertical (m) (Rouge)
                    g.ctx.beginPath(); 
                    g.ctx.strokeStyle = '#c0392b'; g.ctx.lineWidth = 4;
                    g.ctx.moveTo(g.toPixelX(1), g.toPixelY(p_lg));
                    g.ctx.lineTo(g.toPixelX(1), g.toPixelY(p_lg + m_lg)); 
                    g.ctx.stroke();

                    // 5. Point d'arriv√©e
                    g.drawPoint(1, p_lg + m_lg, '#c0392b', 4);

                    // 6. Annotations Textuelles sur le Canvas
                    g.ctx.font = "bold 16px Arial";
                    
                    // Label P
                    g.ctx.fillStyle = '#e67e22';
                    g.ctx.textAlign = "right";
                    g.ctx.fillText(`p=${p_lg}`, g.toPixelX(0) - 15, g.toPixelY(p_lg) + 5);

                    // Label +1
                    g.ctx.fillStyle = '#27ae60';
                    g.ctx.textAlign = "center";
                    g.ctx.fillText("+1", g.toPixelX(0.5), g.toPixelY(p_lg) + (m_lg > 0 ? 20 : -10));

                    // Label m
                    g.ctx.fillStyle = '#c0392b';
                    g.ctx.textAlign = "left";
                    g.ctx.fillText(`m=${m_lg}`, g.toPixelX(1) + 10, g.toPixelY(p_lg + m_lg/2));
                });
            }
        }, 100); // D√©lai pour s'assurer que le DOM est pr√™t
    }
  // ... suite de loadExercise ...

    else if (type === 'solver_simple') {
        // --- 1. G√©n√©ration "Probl√®me Concret" ---
        let a = rand(2, 6);
        let b = rand(10, 50);
        // On s'assure que la cible c donne un r√©sultat positif et entier ou semi-entier
        let targetX = rand(5, 20); 
        let c = a * targetX + b; 
        
        const sujets = [
            { nom: "Alice", unit: "euros", verb: "√©conomise", start: "poss√®de d√©j√†" },
            { nom: "Bob", unit: "points", verb: "gagne", start: "a un score de base de" },
            { nom: "Charlie", unit: "km", verb: "parcourt", start: "a d√©j√† fait" }
        ];
        const context = sujets[Math.floor(Math.random() * sujets.length)];
        const canvasId = 'canvas-solver-' + Date.now();

        // Enonc√©
        area.innerHTML = `${context.nom} ${context.start} <strong>${b}</strong> ${context.unit}.
                <p>Chaque semaine, cette personne ${context.verb} <strong>${a}</strong> ${context.unit} suppl√©mentaires.</p>
                <p>On cherche au bout de combien de semaines (x) elle aura atteint <strong>${c}</strong> ${context.unit}.</p>
                <div class="canvas-container" style="display:none;" id="box-${canvasId}">
                     <canvas id="${canvasId}" width="500" height="300"></canvas>
                </div>
            </div>
        `;

        tags.innerHTML = `
            <span class="tag-helper" onclick="showHint('mise_eq_simple')">Mise en √©quation</span>
            <span class="tag-helper" onclick="showHint('resol_eq')">R√©solution alg√©brique</span>
        `;

        sol.innerHTML = `
            <div class="step-detail">
                <strong>1. Mise en √©quation :</strong><br>
                Valeur initiale = ${b}. Gain par semaine = ${a}.<br>
                On cherche \\( x \\) tel que :
                \\[ ${a}x + ${b} = ${c} \\]
            </div>
            <div class="step-detail">
                <strong>2. R√©solution :</strong><br>
                On soustrait ${b} des deux c√¥t√©s :
                \\[ ${a}x = ${c} - ${b} \\]
                \\[ ${a}x = ${c - b} \\]
                On divise par ${a} :
                \\[ x = \\dfrac{${c - b}}{${a}} = ${targetX} \\]
            </div>
            <div class="highlight">R√©ponse : Il faudra ${targetX} semaines.</div>
            <div style="margin-top:15px; text-align:center; font-style:italic; font-size:0.9rem;">
                (Le graphique est affich√© ci-dessus dans l'√©nonc√© pour visualiser)
            </div>
        `;

        // Afficher le graphique dans la zone √©nonc√© (plus visuel pour ce type)
        setTimeout(() => {
            document.getElementById(`box-${canvasId}`).style.display = 'block';
            drawSolverGraph(canvasId, a, b, c, targetX, false);
        }, 100);
    }

    else if (type === 'solver_percent') {
        // --- 2. G√©n√©ration "Pourcentage" ---
        const isHausse = Math.random() > 0.5;
        const taux = (rand(1, 8) * 5); // 5, 10, 15... 40%
        let prixInitial = rand(5, 20) * 10; // 50, 60... 200
        let prixFinal, coef;
        
        if (isHausse) {
            coef = 1 + taux/100;
            prixFinal = prixInitial * coef;
        } else {
            coef = 1 - taux/100;
            prixFinal = prixInitial * coef;
        }

        const motCle = isHausse ? "d'augmentation" : "de r√©duction";
        const canvasId = 'canvas-percent-' + Date.now();

        area.innerHTML = `Apr√®s une <strong>${isHausse ? 'hausse' : 'baisse'} de ${taux}%</strong>, le prix d'un objet est de <strong>${prixFinal.toFixed(2)} ‚Ç¨</strong>.
                <p>Quel √©tait le prix initial \\( x \\) avant ce changement ?</p>
                <div class="canvas-container" style="display:none;" id="box-${canvasId}">
                     <canvas id="${canvasId}" width="500" height="300"></canvas>
                </div>
            </div>
        `;

        tags.innerHTML = `
            <span class="tag-helper" onclick="showHint('coef_mult')">Coefficient Multiplicateur</span>
            <span class="tag-helper" onclick="showHint('eq_percent')">√âquation</span>
        `;

        sol.innerHTML = `
            <div class="step-detail">
                <strong>1. Coefficient Multiplicateur (CM) :</strong><br>
                Une ${isHausse ? 'hausse' : 'baisse'} de ${taux}% correspond √† un CM de :
                \\[ CM = 1 ${isHausse ? '+' : '-'} \\dfrac{${taux}}{100} = ${coef.toFixed(2)} \\]
            </div>
            <div class="step-detail">
                <strong>2. Mise en √©quation :</strong><br>
                \\( \\text{Prix Initial} \\times CM = \\text{Prix Final} \\)<br>
                \\[ x \\times ${coef.toFixed(2)} = ${prixFinal.toFixed(2)} \\]
            </div>
            <div class="step-detail">
                <strong>3. R√©solution :</strong><br>
                \\[ x = \\dfrac{${prixFinal.toFixed(2)}}{${coef.toFixed(2)}} \\]
                \\[ x = ${prixInitial} \\]
            </div>
            <div class="highlight">Le prix initial √©tait de ${prixInitial} ‚Ç¨.</div>
        `;

        setTimeout(() => {
            document.getElementById(`box-${canvasId}`).style.display = 'block';
            // Pour le dessin, b = 0 car c'est une fonction lin√©aire f(x) = ax
            drawSolverGraph(canvasId, coef, 0, prixFinal, prixInitial, true);
        }, 100);
    }



    // Rendu MathJax
    if(window.MathJax) MathJax.typesetPromise([area, tags, sol]);
}

function showHint(key) {
    const box = document.getElementById('help-content');
    let text = "";
    switch(key) {
        case 'subst': text = "Remplacez x par xA dans mx+p et calculez le r√©sultat."; break;
        case 'form_m': text = "<strong>Formule :</strong> \\( m = \\dfrac{y_B - y_A}{x_B - x_A} \\)."; break;
        case 'form_p_from_m': text = "Utilisez \\( p = y_A - m \\times x_A \\)."; break;
        case 'signes': text = "Attention : \\( - (-a) = + a \\)."; break;
	case 'rappel_eq': text = "Une √©quation de droite s'√©crit toujours y = mx + p. Ici, vous connaissez d√©j√† p."; break;
        case 'isol_m': text = "Remplacez x et y par les coordonn√©es du point A dans l'√©quation y = mx + p, puis r√©solvez l'√©quation pour trouver m."; break;
	case 'rappel_forme_m': text = "L'√©quation est de la forme y = mx + p. Ici, m est donn√© directement dans l'√©nonc√©."; break;
        	    case 'calc_p_from_m': text = "Remplacez y, x et m par leurs valeurs dans l'√©quation y = mx + p, puis calculez p."; break;
	case 'mise_eq_simple': text = "La quantit√© totale est √©gale √† la quantit√© de d√©part + (gain par semaine √ó nombre de semaines)."; break;
                    case 'resol_eq': text = "Isolez x : d'abord soustrayez la valeur constante, puis divisez par le coefficient devant x."; break;
                    case 'coef_mult': text = "Augmenter de t%, c'est multiplier par (1 + t/100). Diminuer de t%, c'est multiplier par (1 - t/100)."; break;
                    case 'eq_percent': text = "L'√©quation est toujours : Valeur Initiale √ó Coefficient = Valeur Finale."; break;
        default: text = "Pas d'indice disponible.";
    }
    box.innerHTML = text;
    if(window.MathJax) MathJax.typesetPromise([box]);
}
    </script>
</body>
</html>
